{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programmieren I \u00b6 Herzlich willkommen zur Programmieren I Veranstaltung! Wir werden unter Verwendung der Programmiersprache Java die wesentlichen Konzepte lernen, die f\u00fcr das Verst\u00e4ndnis modernen Programmierens notwendig sind. Es sind keinerlei Vorkenntnisse erforderlich. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben: L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen! Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung! Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. Programmieren lernt man nur durch Programmieren! Sie m\u00fcssen es tun . Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, prohgrammieren... Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler! Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens. Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid! Viel Erfolg! Und viel Spa\u00df! Organisatorisches \u00b6 Der Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt: Themen werden ausf\u00fchrlich in der Vorlesung vorgestellt und in diesem Skript beschrieben. Es ist geplant, die neuen Themen stets vorab in diesem Skript hier zu ver\u00f6ffentlichen. Sie k\u00f6nnen sich also bereits vorab mit dem jeweiligen neuen Thema besch\u00e4ftigen. Zusammen mit dem Skript (das neue Thema) werden sowohl die dazugeh\u00f6rige \u00dcbung als auch die dazugeh\u00f6rige Aufgabe hochgeladen. Die beiden \u00dcbungen am Dienstag und am Mittwoch sind jeweils gleich (d.h. dort werden die gleichen \u00dcbungsaufgaben gel\u00f6st). Die \u00dcbungen behandeln den Stoff, der am Dienstag in der gleichen Woche besprochen wird. Das bedeutet: das neue Thema wird am Dienstag in der Vorlesung vermittelt und direkt danach oder an dem folgenden Mittwoch in der \u00dcbung angewendet. Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie besuchen. Sie k\u00f6nnen auch beliebig w\u00f6chentlich wechseln. Es wird ein Tutorium angeboten (Termin wird noch bekanntgegeben). Sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu. Zur erfolgreichen Durchf\u00fchrung der Veranstaltung m\u00fcssen Sie die Aufgaben (Hausaufgaben) l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Wenn Sie alle Aufgaben fristgerecht hochgeladen haben, d\u00fcrfen Sie an der Klausur teilnehmen. Es werden insgesamt wahrscheinlich 12 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen m\u00fcssen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Laden Sie dann aber bitte beide jeweils die L\u00f6sung hoch. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr \"Programmieren 1\". Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht meistens jeweils einem Wochenthema. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen , die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, dass Sie sich diese gegenseitig beantworten. Damit w\u00e4re allen geholfen und wir k\u00f6nnen besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Bei Bedarf beantworten die Lehrenden die Fragen nat\u00fcrlich. Planung \u00b6 Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Woche Themen (Vorlesung) Aufgabe Abgabe Aufgabe bis 1. 10.-14.10.2022 Organisatorisches , Algorithmen und Erstes Programm - - 2. 17.-21.10.2022 Variablen und Datentypen sowie Operatoren und Ausdr\u00fccke Aufgabe 1 25.10.2022 3. 24.-28.10.2022 Methoden Aufgabe 2 01.11.2022 4. 31.-04.11.2022 Selektion (if) und Iteration (for) Aufgabe 3 08.11.2022 5. 07.-11.11.2022 Iteration (while) Aufgabe 4 15.11.2022 6. 14.-18.11.2022 Klassen und Objekte Aufgabe 5 22.11.2022 7. 21.-25.11.2022 Konstruktoren, this, eigene Datentypen, R\u00fcckgabe von Objekten Aufgabe 6 29.11.2022 8. 28.-02.12.2022 Eigene Datentypen in Datentypen verwenden Aufgabe 7 06.12.2022 9. 05.-09.12.2022 Vererbung, Object und Polymorphie Aufgabe 8 13.12.2022 10. 12.-16.12.2022 Arrays Aufgabe 9 03.01.2023 11. 19.-23.12.2022 Algorithmen \u00fcber Arrays Aufgabe 10 10.01.2023 12. 02.-06.01.2023 Sortieren von Arrays Aufgabe 11 17.01.2023 13. 09.-13.01.2023 Suchen in Arrays Aufgabe 12 24.01.2023 14. 16.-20.01.2023 Wiederholung, Klausurvorbereitung - - 15. 23.-27.01.2023 Wiederholung, Klausurvorbereitung - - 16. tba Klausur - -","title":"Home"},{"location":"#programmieren-i","text":"Herzlich willkommen zur Programmieren I Veranstaltung! Wir werden unter Verwendung der Programmiersprache Java die wesentlichen Konzepte lernen, die f\u00fcr das Verst\u00e4ndnis modernen Programmierens notwendig sind. Es sind keinerlei Vorkenntnisse erforderlich. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben: L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen! Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung! Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. Programmieren lernt man nur durch Programmieren! Sie m\u00fcssen es tun . Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, prohgrammieren... Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler! Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens. Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid! Viel Erfolg! Und viel Spa\u00df!","title":"Programmieren I"},{"location":"#organisatorisches","text":"Der Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt: Themen werden ausf\u00fchrlich in der Vorlesung vorgestellt und in diesem Skript beschrieben. Es ist geplant, die neuen Themen stets vorab in diesem Skript hier zu ver\u00f6ffentlichen. Sie k\u00f6nnen sich also bereits vorab mit dem jeweiligen neuen Thema besch\u00e4ftigen. Zusammen mit dem Skript (das neue Thema) werden sowohl die dazugeh\u00f6rige \u00dcbung als auch die dazugeh\u00f6rige Aufgabe hochgeladen. Die beiden \u00dcbungen am Dienstag und am Mittwoch sind jeweils gleich (d.h. dort werden die gleichen \u00dcbungsaufgaben gel\u00f6st). Die \u00dcbungen behandeln den Stoff, der am Dienstag in der gleichen Woche besprochen wird. Das bedeutet: das neue Thema wird am Dienstag in der Vorlesung vermittelt und direkt danach oder an dem folgenden Mittwoch in der \u00dcbung angewendet. Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie besuchen. Sie k\u00f6nnen auch beliebig w\u00f6chentlich wechseln. Es wird ein Tutorium angeboten (Termin wird noch bekanntgegeben). Sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu. Zur erfolgreichen Durchf\u00fchrung der Veranstaltung m\u00fcssen Sie die Aufgaben (Hausaufgaben) l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Wenn Sie alle Aufgaben fristgerecht hochgeladen haben, d\u00fcrfen Sie an der Klausur teilnehmen. Es werden insgesamt wahrscheinlich 12 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen m\u00fcssen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Laden Sie dann aber bitte beide jeweils die L\u00f6sung hoch. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr \"Programmieren 1\". Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht meistens jeweils einem Wochenthema. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen , die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, dass Sie sich diese gegenseitig beantworten. Damit w\u00e4re allen geholfen und wir k\u00f6nnen besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Bei Bedarf beantworten die Lehrenden die Fragen nat\u00fcrlich.","title":"Organisatorisches"},{"location":"#planung","text":"Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Woche Themen (Vorlesung) Aufgabe Abgabe Aufgabe bis 1. 10.-14.10.2022 Organisatorisches , Algorithmen und Erstes Programm - - 2. 17.-21.10.2022 Variablen und Datentypen sowie Operatoren und Ausdr\u00fccke Aufgabe 1 25.10.2022 3. 24.-28.10.2022 Methoden Aufgabe 2 01.11.2022 4. 31.-04.11.2022 Selektion (if) und Iteration (for) Aufgabe 3 08.11.2022 5. 07.-11.11.2022 Iteration (while) Aufgabe 4 15.11.2022 6. 14.-18.11.2022 Klassen und Objekte Aufgabe 5 22.11.2022 7. 21.-25.11.2022 Konstruktoren, this, eigene Datentypen, R\u00fcckgabe von Objekten Aufgabe 6 29.11.2022 8. 28.-02.12.2022 Eigene Datentypen in Datentypen verwenden Aufgabe 7 06.12.2022 9. 05.-09.12.2022 Vererbung, Object und Polymorphie Aufgabe 8 13.12.2022 10. 12.-16.12.2022 Arrays Aufgabe 9 03.01.2023 11. 19.-23.12.2022 Algorithmen \u00fcber Arrays Aufgabe 10 10.01.2023 12. 02.-06.01.2023 Sortieren von Arrays Aufgabe 11 17.01.2023 13. 09.-13.01.2023 Suchen in Arrays Aufgabe 12 24.01.2023 14. 16.-20.01.2023 Wiederholung, Klausurvorbereitung - - 15. 23.-27.01.2023 Wiederholung, Klausurvorbereitung - - 16. tba Klausur - -","title":"Planung"},{"location":"algorithmen/","text":"Was ist Programmieren? \u00b6 Zun\u00e4chst ein bisschen Motivation: 10 Gr\u00fcnde, Programmieren zu lernen und Bericht einer ehemaligen FIW-Studentin . Ehe wir uns weiter mit Java und Programmierkonzepten besch\u00e4ftigen, wollen wir uns bewusst werden, was Programmieren \u00fcberhaupt ist. Prinzipiell l\u00f6sen wir beim Programmieren ein Problem mithilfe einer Programmiersprache. Dabei stellt sich die Frage, welche Probleme mithilfe eines Computers l\u00f6sbar sind und welche nicht. Dazu gibt es umfangreiche theoretische Untersuchungen - viele davon werden Sie in den \"Grundlegenden Konzepten der Informatik\" diskutieren. Ein wesentlicher Begriff dabei ist Algorithmus . Ein Algorithmus ist eine eindeutige Handlungsvorschrift, die aus endlich vielen einzelnen Schritten besteht und ein Problem l\u00f6st. Algorithmen sind also auch Kochrezepte oder Bauanleitungen, wenn sie denn \"eindeutig\" sind. Wir kennen alle das Problem, dass Handlungsanweisungen nicht immer eindeutig sind - man kann es manchmal so oder so machen. In der Programmierung darf eine solche Mehrdeutigkeit nat\u00fcrlich nicht vorkommen. Der Algorithmusbegriff wurde deshalb detailliert und folgende Eigenschaften m\u00fcssen f\u00fcr eine Handlungsanweisung f\u00fcr einen Computer gelten, um ein Algorithmus zu sein: Finitheit Das Verfahren muss in einem endlichen Text (Programm) eindeutig beschreibbar sein. Ausf\u00fchrbarkeit Jeder einzelne Schritt des Verfahrens muss auch tats\u00e4chlich ausf\u00fchrbar sein. Dynamische Finitheit Das Verfahren darf zu jedem Zeitpunkt nur endlich viel Speicherplatz ben\u00f6tigen. Terminierung Das Verfahren muss irgendwann enden, d.h. darf nur endlich viele Ausf\u00fchrungsschritte ben\u00f6tigen. Determiniertheit Das Verfahren muss bei denselben Voraussetzungen das gleiche Ergebnis liefern. Determinismus Die n\u00e4chste anzuwendende Regel im Verfahren ist zu jedem Zeitpunkt (in jedem Zustand) eindeutig definiert. Beispiel: Euklidischer Algorithmus \u00b6 Mit dem euklidischen Algorithmus 1 kann der gr\u00f6\u00dfte gemeinsame Teiler (ggT) zweier Zahlen berechnet werden. In seinen Elementen hat Euklid diesen Algorithmus ungef\u00e4hr so formuliert: Euklidischer Algorithmus Wenn CD aber AB nicht misst, und man nimmt bei AB, CD abwechselnd immer das kleinere vom gr\u00f6\u00dferen weg, dann muss (schlie\u00dflich) eine Zahl \u00fcbrig bleiben, die die vorangehende misst. Hm, das ist recht schwierig zu verstehen. Euklid betrachtet die beiden Zahlen, von denen der gr\u00f6\u00dfte gemeinsame Teiler ermittelt werden soll, als Strecken ( AB und CD ). Er zieht wiederholt die kleinere der beiden Strecken von der gr\u00f6\u00dferen ab. Er wiederholt dies solange, bis die beiden Strecken gleich lang sind - genauer: er wiederholt dies solange, solange die beiden Strecken nicht gleich lang sind ( ... CD aber AB nicht misst... ). Beispiel: ggT von 24 und 40 AB: 40, CD: 24, AB gr\u00f6\u00dfer als CD \u2192 40 - 24 = 16 AB: 16, CD: 24, CD gr\u00f6\u00dfer als AB \u2192 24 - 16 = 8 AB: 16, CD: 8, AB gr\u00f6\u00dfer als CD \u2192 16 - 8 = 8 AB: 8, CD: 8, AB gleich CD \u2192 Ende \u2192 ggT ist 8 Wir versuchen, den Algorithmus in eine verst\u00e4ndlichere und genauere Sprache zu \u00fcberf\u00fchren, ohne bereits eine Programmiersprache zu verwenden. Wir benutzen sogenannten Pseudocode : Angenommen, die beiden Zahlen, von denen wir den ggT berechnen wollen, sind a und b : 1 2 3 4 5 6 7 solange a ungleich b ist, wiederhole wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu wenn a gleich b ist, dann: a ( oder auch b ) ist der gesuchte ggT Wichtig ist, dass das Einr\u00fccken hier eine Bedeutung hat (eine Semantik ). In Zeile 1 formulieren wir, dass sich etwas wiederholen soll, solange eine bestimmte Bedingung gilt. Das, was sich wiederholen soll, ist in den Zeilen 2 bis 5 formuliert. Zeile 1 formuliert eine Schleife und in den Zeilen 2 - 5 befindet sich der Schleifeninhalt . Die Zeilen 2 - 5 formulieren ein eigenes Konstrukt, n\u00e4mlich eine Auswahl zwischen Alternativen, abh\u00e4ngig von einer Bedingung. Die Bedingung ist, ob a gr\u00f6\u00dfer ist als b . Wenn das der Fall ist, dann wird die Alternative ziehe b von a ab und weise das Ergebnis a zu ausgef\u00fchrt (In der Programmierung werden das sp\u00e4ter als a = a - b schreiben - das sieht f\u00fcr uns jetzt noch sehr \"falsch\" aus). Ist jedoch a nicht gr\u00f6\u00dfer als b , dann wird die Alternative ziehe a von b ab und weise das Ergebnis b zu ( b = b - a ) ausgef\u00fchrt. Ein solches Konstrukt wird Selektion (oder auch bedingte Alternative ) genannt. Nachdem entweder Zeile 3 oder Zeile 5 ausgef\u00fchrt wurde (es wird genau eins von beiden ausgef\u00fchrt), wird erneut in Zeile 1 gepr\u00fcft, ob a ungleich b ist. Wenn ja, wird die Selektion wiederholt. Wenn nicht, dann ist die Schleife beendet und Zeile 6 wird ausgef\u00fchrt. Die in Zeile 6 formulierte Bedingung wenn a gleich b ist , ist eigentlich unn\u00f6tig. Frage Warum ist die Bedingung wenn a gleich b ist in Zeile 6 unn\u00f6tig? Wir betrachten nochmals die im obigen Algorithmus betrachteten Konstrukte (wir sprechen vom Kontrollfluss von Anweisungen ): Iteration : die Schleife, die in Zeile 1 formuliert wird und die als Schleifeninhalt die Zeilen 2 - 5 hat, beschreibt einen iterativen (sich wiederholenden) Kontrollfluss . Selektion : die bedingte Alternative , die eine Bedingung pr\u00fcft (Zeile 2 ) und dann, je nachdem, ob die Bedingung richtig oder falsch ist, jeweils eine alternative Anweisung ausf\u00fchrt (entweder Zeile 3 oder Zeile 4 ), wird Selektion genannt (siehe Zeilen 2 - 5 ). Sequenz : die Anweisungen werden hintereinander ausgef\u00fchrt, erst Zeile 1 , dann Zeile 2 , dann entweder Zeile 3 oder Zeile 4 usw. Das Hintereinanderausf\u00fchren von Anweisungen wird Sequenz genannt. Schauen wir uns f\u00fcr unseren Algorithmus nochmal die Eigenschaften eines Algorithmus an: Finitheit unsere Beschreibung des Algorithmus ist endlich (siehe oben). Ausf\u00fchrbarkeit jeder einzelne Schritt kann ausgef\u00fchrt werden. Dynamische Finitheit \u00fcber den Speicherplatz k\u00f6nnen wir noch nicht viel sagen, aber wir m\u00fcssen nur einige wenige Zahlen speichern. Das sollte klappen. Terminierung Wann endet unser Algorithmus? Was muss gelten? Wissen wir, ob der Algorithmus irgendwann stoppt? Determiniertheit Es ist sicherlich nicht so leicht zu sehen, ob bei gleicher Eingabe (die Zahlen a und b ) auch stets der gleiche gr\u00f6\u00dfte gemneinsame Teiler berechnet wird. Dazu m\u00fcssten wir uns erstmal \u00fcberlegen, wie wir das pr\u00fcfen k\u00f6nnen. Determinismus Wir werden unseren Algorithmus nochmal an einem Beispiel durchspielen , um ein Gef\u00fchl daf\u00fcr zu bekommen, dass wir stets wissen, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Beispielzahlen f\u00fcr den euklidischen Algorithmus \u00b6 Wir nehmen die Zahlen a=40 und b=24 und spielen damit unseren Algorithmus durch: Zeile 1 : a (40) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von a-b ist 16. Der neue Wert von a ist 16. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist nicht gr\u00f6\u00dfer als b , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von b-a ist 8. Der neue Wert von b ist 8. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (8) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeile 5 ) Zeile 3 : das Ergebnis von a-b ist 8. Der neue Wert von a ist 8. Zeile 1 : wegen wiederhole (Iteration): a (8) ist nicht ungleich b (8) , also wird der Schleifeninhalt nicht ausgef\u00fchrt Zeile 6 : a (8) ist gleich b (8) Zeile 7 : der gesuchte ggT ist 8 Ende F\u00fcr dieses Beispiel war stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die die Eingabe a=40 und b=24 stets 8 ist. Fragen Was \u00e4ndert sich, wenn am Anfang a=24 und b=40 sind? Was \u00e4ndert sich, wenn am Anfang a=-40 und b=24 sind? Was \u00e4ndert sich, wenn am Anfang a=0 und b=24 sind? Was \u00e4ndert sich, wenn am Anfang a=24 und b=24 sind? Beispiel: (3n+1)-Vermutung (Collatz-Problem) \u00b6 Wir betrachten noch einen weiteren Algorithmus: Als Eingabe bekommen wir eine positive nat\u00fcrliche Zahl, z.B. 5 . Der Algorithmus berechnet eine Folge von Zahlen und zwar nach folgender Vorschrift: ist die Zahl ungerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl mit 3 multipliziert und dann 1 addiert wird. Ist die Zahl gerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl durch 2 geteilt wird. Der Algorithmus stoppt, wenn der Nachfolger 1 ist. Angenommen, die eingegebene positive nat\u00fcrliche Zahl ist n : 1 2 3 4 5 solange n ungleich 1 ist, wiederhole wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Wir begeben uns also in eine Schleife und berechnen so lange einen Nachfolger f\u00fcr die Zahl bis der Nachfolger 1 ist. Betrachten wir den Algorithmus f\u00fcr die Eingabe von n=5 : Zeile 1 : n (5) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist ungerade , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von 3*5+1 ist 16 . Der neue Wert von n ist 16. Zeile 1 : wegen wiederhole (Iteration): n (16) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 16/2 ist 8 . Der neue Wert von n ist 8. Zeile 1 : wegen wiederhole (Iteration): n (8) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 8/2 ist 4 . Der neue Wert von n ist 4. Zeile 1 : wegen wiederhole (Iteration): n (4) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 4/2 ist 2 . Der neue Wert von n ist 2. Zeile 1 : wegen wiederhole (Iteration): n (2) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 2/2 ist 1 . Der neue Wert von n ist 1. Zeile 1 : wegen wiederhole (Iteration): n (1) ist nicht ungleich 1 , also wird der Schleifeninhalt nicht ausgef\u00fchrt Ende Auch f\u00fcr dieses Beispiel war erneut stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die Eingabe n=5 stets 1 ist. Fragen Spielen Sie den Algorithmus ruhig einmal f\u00fcr n=7 durch oder auch f\u00fcr andere n Denken Sie, dass der Algorithmus f\u00fcr jede beliebige positive nat\u00fcrliche Zahl n terminiert? Wenn ein Algorithmus f\u00fcr eine konkrete Eingabe stets ein eindeutiges Ergebnis (und zwar immer das gleiche) liefert, wie k\u00f6nnen dann Zufallszahlen berechnet werden? Success Wir haben ein Verst\u00e4ndnis \u00fcber den Algorithmus -Begriff erlangt und wissen, was Finitheit , Determiniertheit , Determinismus und Terminierung bedeuten. Programmablaufstrukturen \u00b6 Interessanterweise gibt es nur drei verschiedene Ablaufstrukturen in Programmen bzw. Algorithmen. Alle drei haben wir bereits verwendet. Mit Ablaufstrukturen meinen wir die Abarbeitungsreihenfolge von Anweisungen. Man sagt auch Kontrollfluss dazu. Die drei Ablaufstrukturen, die es gibt, sind: die Sequenz : die Anweisungen werden in sequenzieller Abfolge, d.h. hintereinander ausgef\u00fchrt die Iteration : die Abl\u00e4ufe werden wiederholt ausgef\u00fchrt, also in einer Schleife die Selektion : die Abl\u00e4ufe werden selektiv , d.h. unter einer bestimmten Bedingung ausgef\u00fchrt. Man nennt diese Struktur auch Verzweigung oder bedingte Alternative Wir schauen uns alle drei Kontrollstrukturen einmal genauer an. Die Sequenz \u00b6 Bei der Sequenz handelt es sich einfach um hintereinander ausgef\u00fchrte Anweisungen. Es wird stets erst die eine Anweisung vollst\u00e4ndig abgearbeitet, ehe die andere begonnen wird. Sequenz von 3 Anweisungen Anweisung1 Anweisung2 Anweisung3 Ein Beispiel (mit 2 Anweisungen) w\u00e4re: berechne 3 *n und weise das Ergebnis n zu berechne n+1 und weise das Ergebnis n zu Zur Visualisierung von Kontrollstrukturen werden auch sogannnte Programmablaufdiagramme oder Programmablaufpl\u00e4ne verwendet. F\u00fcr eine Sequenz s\u00e4he ein solches Ablaufdiagramm so aus: So ein Diagramm wird von oben nach unten gelesen. Es wird also erst Anweisung1 ausgef\u00fchrt, dann Anweisung2 und zuletzt Anweisung3 . Innerhalb einer Sequenz gilt immer single entry / single exit , d.h. keine der Anweisungen innerhalb einer Sequenz kann mehrere Ausg\u00e4nge oder mehrere Eing\u00e4nge haben. Es w\u00e4re ansonsten nicht-deterministisch und somit ein Versto\u00df gegen unseren Algorithmusbegriff. Die Iteration \u00b6 Bei der Iteration handelt es sich um eine wiederholte Ausf\u00fchrung einer Anweisung bzw. einer Sequenz von Anweisungen. Wie oft eine Iteration ausgef\u00fchrt wird, h\u00e4ngt von einer Bedingung ab. In der Programmierung sprechen wir bei der Iteration auch von einer Schleife . Bedingungen f\u00fcr eine solche Schleife haben wir bereits kennengelernt: solange a ungleich b ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt bzw. solange n ungleich 1 ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt Wichtig ist, dass es auch hier eine strikte Reihenfolge der Abarbeitung der Anweisungen gibt: es wird zun\u00e4chst gepr\u00fcft, ob die Bedingung erf\u00fcllt (wahr) ist, also ob z.B. a ungleich b ist oder ob n ungleich 1 . Wenn diese Bedingung erf\u00fcllt (also wahr) ist, dann werden die Anweisung(en) innerhalb der Schleife nacheinander (sequenziell) abgearbeitet. Erst wenn alle Anweisungen innerhalb der Schleife abgearbeitet wurden, wird die Schleifenbedingung erneut gepr\u00fcft. Ist sie wieder wahr, werden die Anweisungen innerhalb der Schleife erneut abgearbeitet usw. Ist sie nicht wahr, also wenn z.B. a gleich b ist oder n gleich 1 ist , dann wird die Schleife beendet und die Anweisungen innerhalb der Schleife nicht (erneut) abgearbeitet. Das Ablaufdiagramm einer Schleife (Iteration) sieht so aus: Die eigentliche Iteration ist gr\u00fcn dargestellt. Wir kommen von einer anderen Anweisung und pr\u00fcfen die Bedingung. Ist sie wahr, wird Anweisung1 ausgef\u00fchrt. Beachte Anweisung1 muss nicht zwingend nur genau eine Anweisung sein. Bei Anweisung1 kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder sogar selbst um eine Iteration (Schleife in der Schleife - verschachtelte Schleife) handeln! Nach jeder Ausf\u00fchrung von Anweisung1 wird die Bedingung erneut gepr\u00fcft. Ist sie (immernoch) wahr, wird Anweisung1 erneut ausgef\u00fchrt. Ist die Bedingung jedoch falsch, dann wird Anweisung1 nicht (mehr) ausgef\u00fchrt, sondern die Schleife wird verlassen und die Anweisung, die der Schleife folgt, wird ausgef\u00fchrt ( Anweisung2 ) oder das Programm ist dann zu Ende. Beachte Es kann sein, dass Anweisung1 gar nicht ausgef\u00fchrt wird, weil die Bedingung bereits bei der ersten Pr\u00fcfung falsch ist. Es ist also nicht gesagt, dass sich eine Iteration wirklich wiederholt . Es kann sein, dass Anweisung1 gar nicht oder nur genau ein Mal ausgef\u00fchrt wird (wenn die Bedingung nach der ersten Ausf\u00fchrung falsch ist). Das ist kein Problem! Ein Problem ist es jedoch, wenn die Bedingung niemals falsch wird und die Schleife unendlich oft hintereinander ausgef\u00fchrt wird. Das ist ein Versto\u00df gegen die Terminierung eines Algorithmus. In einem solchen Fall werden wir irgendwann einen Fehler bei der Programmausf\u00fchrung erhalten (aber erst zur Ausf\u00fchrungszeit, nicht bereits beim Compilieren). Wir werden uns ausf\u00fchrlich mit Schleifen auseinandersetzen, da sie logisch recht anspruchsvoll und dadurch h\u00e4ufig fehleranf\u00e4llig sein k\u00f6nnen. Die Selektion \u00b6 Bei der Selektion handelt es sich, im Gegensatz zur Iteration, um eine einmalige Ausf\u00fchrung einer (oder mehrerer) Anweisung(en). Jedoch ist diese Ausf\u00fchrung, im Gegensatz zur Sequenz, von einer Bedingung abh\u00e4ngig. Wir hatten eine solche Selektion jeweils in obigen Beispielalgorithmen. Selektion aus dem euklidischen Algorithmus: wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu Selektion aus der (3n+1)-Vermutung (dem Collatz-Problem): wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Es gibt also immer eine Bedingung (z.B. wenn a gr\u00f6\u00dfer ist als b ) und abh\u00e4ngig vom Wert dieser Bedingung (wahr oder falsch), wird entweder die eine Anweisung (z.B. ziehe b von a ab und weise das Ergebnis a zu ) oder die andere (z.B. ziehe a von b ab und weise das Ergebnis b zu ) ausgef\u00fchrt. Das Ablaufdiagramm einer Selektion sieht so aus: Beachte Anweisung1 und auch Anweisung2 m\u00fcssen nicht zwingend jeweils nur genau eine Anweisung sein. Bei beiden kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder um eine Iteration handeln! Verschachteln von Kontrollstrukturen \u00b6 Mehr als diese drei genannten Kontrollstrukturen gibt es nicht. Aber diese Kontrollstrukturen k\u00f6nnen beliebig ineinander verschachtelt werden. \u00dcberall dort, wo eine Anweisung steht (z.B. Anweisung1 ) kann auch eine komplette Kontrollstruktur eingesetzt werden, also eine Sequenz von Anweisungen oder eine Iteration oder eine Selektion. Die kann dann beliebig fortgef\u00fchrt werden. So entstehen komplexe Strukturen - und somit komplexe Programme. Ein (immernoch recht einfaches) Beispiel f\u00fcr eine etwas komplexere Struktur: \u00dcbung Programmablaufpl\u00e4ne Erstellen Sie sowohl f\u00fcr den euklidischen Algorithmus als auch f\u00fcr die (3n+1)-Vermutung einen Programmablaufplan! \u00dcbung Algorithmus und Programmablaufplan Ein Jahr ist ein Schaltjahr, wenn es sich durch 4 teilen l\u00e4sst. Au\u00dfer, es l\u00e4sst sich durch 100 teilen. Dann ist es doch kein Schaltjahr. Au\u00dfer, es l\u00e4sst sich durch 400 teilen. Dann ist es doch ein Schaltjahr. Beschreiben Sie diese Vorschrift als einen Algorithmus in der Form, in der auch der euklidische Algorithmus und die (3n+1)-Vermutung beschrieben wurden. Erstellen Sie dann den dazugeh\u00f6rigen Programmablaufplan. Success Wir wissen nun, dass es nur drei verschiedene Programmablaufstrukturen gibt: die Sequenz, die Iteration und die Selektion. Wir haben ein Verst\u00e4ndnis davon, was die drei Programmablaufstrukturen ausmacht, welchen Zweck sie haben und was sie voneinander unterscheidet. Wir wissen, dass sich diese Strukturen beliebig ineinander verschachteln lassen. Benannt nach Euklid von Alexandria, einem Mathematiker aus dem 3. Jahrhundert, Autor der Elemente - einem Kompendium des Wissens der Mathematik seiner Zeit. \u21a9","title":"Algorithmen"},{"location":"algorithmen/#was-ist-programmieren","text":"Zun\u00e4chst ein bisschen Motivation: 10 Gr\u00fcnde, Programmieren zu lernen und Bericht einer ehemaligen FIW-Studentin . Ehe wir uns weiter mit Java und Programmierkonzepten besch\u00e4ftigen, wollen wir uns bewusst werden, was Programmieren \u00fcberhaupt ist. Prinzipiell l\u00f6sen wir beim Programmieren ein Problem mithilfe einer Programmiersprache. Dabei stellt sich die Frage, welche Probleme mithilfe eines Computers l\u00f6sbar sind und welche nicht. Dazu gibt es umfangreiche theoretische Untersuchungen - viele davon werden Sie in den \"Grundlegenden Konzepten der Informatik\" diskutieren. Ein wesentlicher Begriff dabei ist Algorithmus . Ein Algorithmus ist eine eindeutige Handlungsvorschrift, die aus endlich vielen einzelnen Schritten besteht und ein Problem l\u00f6st. Algorithmen sind also auch Kochrezepte oder Bauanleitungen, wenn sie denn \"eindeutig\" sind. Wir kennen alle das Problem, dass Handlungsanweisungen nicht immer eindeutig sind - man kann es manchmal so oder so machen. In der Programmierung darf eine solche Mehrdeutigkeit nat\u00fcrlich nicht vorkommen. Der Algorithmusbegriff wurde deshalb detailliert und folgende Eigenschaften m\u00fcssen f\u00fcr eine Handlungsanweisung f\u00fcr einen Computer gelten, um ein Algorithmus zu sein: Finitheit Das Verfahren muss in einem endlichen Text (Programm) eindeutig beschreibbar sein. Ausf\u00fchrbarkeit Jeder einzelne Schritt des Verfahrens muss auch tats\u00e4chlich ausf\u00fchrbar sein. Dynamische Finitheit Das Verfahren darf zu jedem Zeitpunkt nur endlich viel Speicherplatz ben\u00f6tigen. Terminierung Das Verfahren muss irgendwann enden, d.h. darf nur endlich viele Ausf\u00fchrungsschritte ben\u00f6tigen. Determiniertheit Das Verfahren muss bei denselben Voraussetzungen das gleiche Ergebnis liefern. Determinismus Die n\u00e4chste anzuwendende Regel im Verfahren ist zu jedem Zeitpunkt (in jedem Zustand) eindeutig definiert.","title":"Was ist Programmieren?"},{"location":"algorithmen/#beispiel-euklidischer-algorithmus","text":"Mit dem euklidischen Algorithmus 1 kann der gr\u00f6\u00dfte gemeinsame Teiler (ggT) zweier Zahlen berechnet werden. In seinen Elementen hat Euklid diesen Algorithmus ungef\u00e4hr so formuliert: Euklidischer Algorithmus Wenn CD aber AB nicht misst, und man nimmt bei AB, CD abwechselnd immer das kleinere vom gr\u00f6\u00dferen weg, dann muss (schlie\u00dflich) eine Zahl \u00fcbrig bleiben, die die vorangehende misst. Hm, das ist recht schwierig zu verstehen. Euklid betrachtet die beiden Zahlen, von denen der gr\u00f6\u00dfte gemeinsame Teiler ermittelt werden soll, als Strecken ( AB und CD ). Er zieht wiederholt die kleinere der beiden Strecken von der gr\u00f6\u00dferen ab. Er wiederholt dies solange, bis die beiden Strecken gleich lang sind - genauer: er wiederholt dies solange, solange die beiden Strecken nicht gleich lang sind ( ... CD aber AB nicht misst... ). Beispiel: ggT von 24 und 40 AB: 40, CD: 24, AB gr\u00f6\u00dfer als CD \u2192 40 - 24 = 16 AB: 16, CD: 24, CD gr\u00f6\u00dfer als AB \u2192 24 - 16 = 8 AB: 16, CD: 8, AB gr\u00f6\u00dfer als CD \u2192 16 - 8 = 8 AB: 8, CD: 8, AB gleich CD \u2192 Ende \u2192 ggT ist 8 Wir versuchen, den Algorithmus in eine verst\u00e4ndlichere und genauere Sprache zu \u00fcberf\u00fchren, ohne bereits eine Programmiersprache zu verwenden. Wir benutzen sogenannten Pseudocode : Angenommen, die beiden Zahlen, von denen wir den ggT berechnen wollen, sind a und b : 1 2 3 4 5 6 7 solange a ungleich b ist, wiederhole wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu wenn a gleich b ist, dann: a ( oder auch b ) ist der gesuchte ggT Wichtig ist, dass das Einr\u00fccken hier eine Bedeutung hat (eine Semantik ). In Zeile 1 formulieren wir, dass sich etwas wiederholen soll, solange eine bestimmte Bedingung gilt. Das, was sich wiederholen soll, ist in den Zeilen 2 bis 5 formuliert. Zeile 1 formuliert eine Schleife und in den Zeilen 2 - 5 befindet sich der Schleifeninhalt . Die Zeilen 2 - 5 formulieren ein eigenes Konstrukt, n\u00e4mlich eine Auswahl zwischen Alternativen, abh\u00e4ngig von einer Bedingung. Die Bedingung ist, ob a gr\u00f6\u00dfer ist als b . Wenn das der Fall ist, dann wird die Alternative ziehe b von a ab und weise das Ergebnis a zu ausgef\u00fchrt (In der Programmierung werden das sp\u00e4ter als a = a - b schreiben - das sieht f\u00fcr uns jetzt noch sehr \"falsch\" aus). Ist jedoch a nicht gr\u00f6\u00dfer als b , dann wird die Alternative ziehe a von b ab und weise das Ergebnis b zu ( b = b - a ) ausgef\u00fchrt. Ein solches Konstrukt wird Selektion (oder auch bedingte Alternative ) genannt. Nachdem entweder Zeile 3 oder Zeile 5 ausgef\u00fchrt wurde (es wird genau eins von beiden ausgef\u00fchrt), wird erneut in Zeile 1 gepr\u00fcft, ob a ungleich b ist. Wenn ja, wird die Selektion wiederholt. Wenn nicht, dann ist die Schleife beendet und Zeile 6 wird ausgef\u00fchrt. Die in Zeile 6 formulierte Bedingung wenn a gleich b ist , ist eigentlich unn\u00f6tig. Frage Warum ist die Bedingung wenn a gleich b ist in Zeile 6 unn\u00f6tig? Wir betrachten nochmals die im obigen Algorithmus betrachteten Konstrukte (wir sprechen vom Kontrollfluss von Anweisungen ): Iteration : die Schleife, die in Zeile 1 formuliert wird und die als Schleifeninhalt die Zeilen 2 - 5 hat, beschreibt einen iterativen (sich wiederholenden) Kontrollfluss . Selektion : die bedingte Alternative , die eine Bedingung pr\u00fcft (Zeile 2 ) und dann, je nachdem, ob die Bedingung richtig oder falsch ist, jeweils eine alternative Anweisung ausf\u00fchrt (entweder Zeile 3 oder Zeile 4 ), wird Selektion genannt (siehe Zeilen 2 - 5 ). Sequenz : die Anweisungen werden hintereinander ausgef\u00fchrt, erst Zeile 1 , dann Zeile 2 , dann entweder Zeile 3 oder Zeile 4 usw. Das Hintereinanderausf\u00fchren von Anweisungen wird Sequenz genannt. Schauen wir uns f\u00fcr unseren Algorithmus nochmal die Eigenschaften eines Algorithmus an: Finitheit unsere Beschreibung des Algorithmus ist endlich (siehe oben). Ausf\u00fchrbarkeit jeder einzelne Schritt kann ausgef\u00fchrt werden. Dynamische Finitheit \u00fcber den Speicherplatz k\u00f6nnen wir noch nicht viel sagen, aber wir m\u00fcssen nur einige wenige Zahlen speichern. Das sollte klappen. Terminierung Wann endet unser Algorithmus? Was muss gelten? Wissen wir, ob der Algorithmus irgendwann stoppt? Determiniertheit Es ist sicherlich nicht so leicht zu sehen, ob bei gleicher Eingabe (die Zahlen a und b ) auch stets der gleiche gr\u00f6\u00dfte gemneinsame Teiler berechnet wird. Dazu m\u00fcssten wir uns erstmal \u00fcberlegen, wie wir das pr\u00fcfen k\u00f6nnen. Determinismus Wir werden unseren Algorithmus nochmal an einem Beispiel durchspielen , um ein Gef\u00fchl daf\u00fcr zu bekommen, dass wir stets wissen, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird.","title":"Beispiel: Euklidischer Algorithmus"},{"location":"algorithmen/#beispielzahlen-fur-den-euklidischen-algorithmus","text":"Wir nehmen die Zahlen a=40 und b=24 und spielen damit unseren Algorithmus durch: Zeile 1 : a (40) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von a-b ist 16. Der neue Wert von a ist 16. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist nicht gr\u00f6\u00dfer als b , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von b-a ist 8. Der neue Wert von b ist 8. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (8) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeile 5 ) Zeile 3 : das Ergebnis von a-b ist 8. Der neue Wert von a ist 8. Zeile 1 : wegen wiederhole (Iteration): a (8) ist nicht ungleich b (8) , also wird der Schleifeninhalt nicht ausgef\u00fchrt Zeile 6 : a (8) ist gleich b (8) Zeile 7 : der gesuchte ggT ist 8 Ende F\u00fcr dieses Beispiel war stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die die Eingabe a=40 und b=24 stets 8 ist. Fragen Was \u00e4ndert sich, wenn am Anfang a=24 und b=40 sind? Was \u00e4ndert sich, wenn am Anfang a=-40 und b=24 sind? Was \u00e4ndert sich, wenn am Anfang a=0 und b=24 sind? Was \u00e4ndert sich, wenn am Anfang a=24 und b=24 sind?","title":"Beispielzahlen f\u00fcr den euklidischen Algorithmus"},{"location":"algorithmen/#beispiel-3n1-vermutung-collatz-problem","text":"Wir betrachten noch einen weiteren Algorithmus: Als Eingabe bekommen wir eine positive nat\u00fcrliche Zahl, z.B. 5 . Der Algorithmus berechnet eine Folge von Zahlen und zwar nach folgender Vorschrift: ist die Zahl ungerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl mit 3 multipliziert und dann 1 addiert wird. Ist die Zahl gerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl durch 2 geteilt wird. Der Algorithmus stoppt, wenn der Nachfolger 1 ist. Angenommen, die eingegebene positive nat\u00fcrliche Zahl ist n : 1 2 3 4 5 solange n ungleich 1 ist, wiederhole wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Wir begeben uns also in eine Schleife und berechnen so lange einen Nachfolger f\u00fcr die Zahl bis der Nachfolger 1 ist. Betrachten wir den Algorithmus f\u00fcr die Eingabe von n=5 : Zeile 1 : n (5) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist ungerade , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von 3*5+1 ist 16 . Der neue Wert von n ist 16. Zeile 1 : wegen wiederhole (Iteration): n (16) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 16/2 ist 8 . Der neue Wert von n ist 8. Zeile 1 : wegen wiederhole (Iteration): n (8) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 8/2 ist 4 . Der neue Wert von n ist 4. Zeile 1 : wegen wiederhole (Iteration): n (4) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 4/2 ist 2 . Der neue Wert von n ist 2. Zeile 1 : wegen wiederhole (Iteration): n (2) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 2/2 ist 1 . Der neue Wert von n ist 1. Zeile 1 : wegen wiederhole (Iteration): n (1) ist nicht ungleich 1 , also wird der Schleifeninhalt nicht ausgef\u00fchrt Ende Auch f\u00fcr dieses Beispiel war erneut stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die Eingabe n=5 stets 1 ist. Fragen Spielen Sie den Algorithmus ruhig einmal f\u00fcr n=7 durch oder auch f\u00fcr andere n Denken Sie, dass der Algorithmus f\u00fcr jede beliebige positive nat\u00fcrliche Zahl n terminiert? Wenn ein Algorithmus f\u00fcr eine konkrete Eingabe stets ein eindeutiges Ergebnis (und zwar immer das gleiche) liefert, wie k\u00f6nnen dann Zufallszahlen berechnet werden? Success Wir haben ein Verst\u00e4ndnis \u00fcber den Algorithmus -Begriff erlangt und wissen, was Finitheit , Determiniertheit , Determinismus und Terminierung bedeuten.","title":"Beispiel: (3n+1)-Vermutung (Collatz-Problem)"},{"location":"algorithmen/#programmablaufstrukturen","text":"Interessanterweise gibt es nur drei verschiedene Ablaufstrukturen in Programmen bzw. Algorithmen. Alle drei haben wir bereits verwendet. Mit Ablaufstrukturen meinen wir die Abarbeitungsreihenfolge von Anweisungen. Man sagt auch Kontrollfluss dazu. Die drei Ablaufstrukturen, die es gibt, sind: die Sequenz : die Anweisungen werden in sequenzieller Abfolge, d.h. hintereinander ausgef\u00fchrt die Iteration : die Abl\u00e4ufe werden wiederholt ausgef\u00fchrt, also in einer Schleife die Selektion : die Abl\u00e4ufe werden selektiv , d.h. unter einer bestimmten Bedingung ausgef\u00fchrt. Man nennt diese Struktur auch Verzweigung oder bedingte Alternative Wir schauen uns alle drei Kontrollstrukturen einmal genauer an.","title":"Programmablaufstrukturen"},{"location":"algorithmen/#die-sequenz","text":"Bei der Sequenz handelt es sich einfach um hintereinander ausgef\u00fchrte Anweisungen. Es wird stets erst die eine Anweisung vollst\u00e4ndig abgearbeitet, ehe die andere begonnen wird. Sequenz von 3 Anweisungen Anweisung1 Anweisung2 Anweisung3 Ein Beispiel (mit 2 Anweisungen) w\u00e4re: berechne 3 *n und weise das Ergebnis n zu berechne n+1 und weise das Ergebnis n zu Zur Visualisierung von Kontrollstrukturen werden auch sogannnte Programmablaufdiagramme oder Programmablaufpl\u00e4ne verwendet. F\u00fcr eine Sequenz s\u00e4he ein solches Ablaufdiagramm so aus: So ein Diagramm wird von oben nach unten gelesen. Es wird also erst Anweisung1 ausgef\u00fchrt, dann Anweisung2 und zuletzt Anweisung3 . Innerhalb einer Sequenz gilt immer single entry / single exit , d.h. keine der Anweisungen innerhalb einer Sequenz kann mehrere Ausg\u00e4nge oder mehrere Eing\u00e4nge haben. Es w\u00e4re ansonsten nicht-deterministisch und somit ein Versto\u00df gegen unseren Algorithmusbegriff.","title":"Die Sequenz"},{"location":"algorithmen/#die-iteration","text":"Bei der Iteration handelt es sich um eine wiederholte Ausf\u00fchrung einer Anweisung bzw. einer Sequenz von Anweisungen. Wie oft eine Iteration ausgef\u00fchrt wird, h\u00e4ngt von einer Bedingung ab. In der Programmierung sprechen wir bei der Iteration auch von einer Schleife . Bedingungen f\u00fcr eine solche Schleife haben wir bereits kennengelernt: solange a ungleich b ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt bzw. solange n ungleich 1 ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt Wichtig ist, dass es auch hier eine strikte Reihenfolge der Abarbeitung der Anweisungen gibt: es wird zun\u00e4chst gepr\u00fcft, ob die Bedingung erf\u00fcllt (wahr) ist, also ob z.B. a ungleich b ist oder ob n ungleich 1 . Wenn diese Bedingung erf\u00fcllt (also wahr) ist, dann werden die Anweisung(en) innerhalb der Schleife nacheinander (sequenziell) abgearbeitet. Erst wenn alle Anweisungen innerhalb der Schleife abgearbeitet wurden, wird die Schleifenbedingung erneut gepr\u00fcft. Ist sie wieder wahr, werden die Anweisungen innerhalb der Schleife erneut abgearbeitet usw. Ist sie nicht wahr, also wenn z.B. a gleich b ist oder n gleich 1 ist , dann wird die Schleife beendet und die Anweisungen innerhalb der Schleife nicht (erneut) abgearbeitet. Das Ablaufdiagramm einer Schleife (Iteration) sieht so aus: Die eigentliche Iteration ist gr\u00fcn dargestellt. Wir kommen von einer anderen Anweisung und pr\u00fcfen die Bedingung. Ist sie wahr, wird Anweisung1 ausgef\u00fchrt. Beachte Anweisung1 muss nicht zwingend nur genau eine Anweisung sein. Bei Anweisung1 kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder sogar selbst um eine Iteration (Schleife in der Schleife - verschachtelte Schleife) handeln! Nach jeder Ausf\u00fchrung von Anweisung1 wird die Bedingung erneut gepr\u00fcft. Ist sie (immernoch) wahr, wird Anweisung1 erneut ausgef\u00fchrt. Ist die Bedingung jedoch falsch, dann wird Anweisung1 nicht (mehr) ausgef\u00fchrt, sondern die Schleife wird verlassen und die Anweisung, die der Schleife folgt, wird ausgef\u00fchrt ( Anweisung2 ) oder das Programm ist dann zu Ende. Beachte Es kann sein, dass Anweisung1 gar nicht ausgef\u00fchrt wird, weil die Bedingung bereits bei der ersten Pr\u00fcfung falsch ist. Es ist also nicht gesagt, dass sich eine Iteration wirklich wiederholt . Es kann sein, dass Anweisung1 gar nicht oder nur genau ein Mal ausgef\u00fchrt wird (wenn die Bedingung nach der ersten Ausf\u00fchrung falsch ist). Das ist kein Problem! Ein Problem ist es jedoch, wenn die Bedingung niemals falsch wird und die Schleife unendlich oft hintereinander ausgef\u00fchrt wird. Das ist ein Versto\u00df gegen die Terminierung eines Algorithmus. In einem solchen Fall werden wir irgendwann einen Fehler bei der Programmausf\u00fchrung erhalten (aber erst zur Ausf\u00fchrungszeit, nicht bereits beim Compilieren). Wir werden uns ausf\u00fchrlich mit Schleifen auseinandersetzen, da sie logisch recht anspruchsvoll und dadurch h\u00e4ufig fehleranf\u00e4llig sein k\u00f6nnen.","title":"Die Iteration"},{"location":"algorithmen/#die-selektion","text":"Bei der Selektion handelt es sich, im Gegensatz zur Iteration, um eine einmalige Ausf\u00fchrung einer (oder mehrerer) Anweisung(en). Jedoch ist diese Ausf\u00fchrung, im Gegensatz zur Sequenz, von einer Bedingung abh\u00e4ngig. Wir hatten eine solche Selektion jeweils in obigen Beispielalgorithmen. Selektion aus dem euklidischen Algorithmus: wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu Selektion aus der (3n+1)-Vermutung (dem Collatz-Problem): wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Es gibt also immer eine Bedingung (z.B. wenn a gr\u00f6\u00dfer ist als b ) und abh\u00e4ngig vom Wert dieser Bedingung (wahr oder falsch), wird entweder die eine Anweisung (z.B. ziehe b von a ab und weise das Ergebnis a zu ) oder die andere (z.B. ziehe a von b ab und weise das Ergebnis b zu ) ausgef\u00fchrt. Das Ablaufdiagramm einer Selektion sieht so aus: Beachte Anweisung1 und auch Anweisung2 m\u00fcssen nicht zwingend jeweils nur genau eine Anweisung sein. Bei beiden kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder um eine Iteration handeln!","title":"Die Selektion"},{"location":"algorithmen/#verschachteln-von-kontrollstrukturen","text":"Mehr als diese drei genannten Kontrollstrukturen gibt es nicht. Aber diese Kontrollstrukturen k\u00f6nnen beliebig ineinander verschachtelt werden. \u00dcberall dort, wo eine Anweisung steht (z.B. Anweisung1 ) kann auch eine komplette Kontrollstruktur eingesetzt werden, also eine Sequenz von Anweisungen oder eine Iteration oder eine Selektion. Die kann dann beliebig fortgef\u00fchrt werden. So entstehen komplexe Strukturen - und somit komplexe Programme. Ein (immernoch recht einfaches) Beispiel f\u00fcr eine etwas komplexere Struktur: \u00dcbung Programmablaufpl\u00e4ne Erstellen Sie sowohl f\u00fcr den euklidischen Algorithmus als auch f\u00fcr die (3n+1)-Vermutung einen Programmablaufplan! \u00dcbung Algorithmus und Programmablaufplan Ein Jahr ist ein Schaltjahr, wenn es sich durch 4 teilen l\u00e4sst. Au\u00dfer, es l\u00e4sst sich durch 100 teilen. Dann ist es doch kein Schaltjahr. Au\u00dfer, es l\u00e4sst sich durch 400 teilen. Dann ist es doch ein Schaltjahr. Beschreiben Sie diese Vorschrift als einen Algorithmus in der Form, in der auch der euklidische Algorithmus und die (3n+1)-Vermutung beschrieben wurden. Erstellen Sie dann den dazugeh\u00f6rigen Programmablaufplan. Success Wir wissen nun, dass es nur drei verschiedene Programmablaufstrukturen gibt: die Sequenz, die Iteration und die Selektion. Wir haben ein Verst\u00e4ndnis davon, was die drei Programmablaufstrukturen ausmacht, welchen Zweck sie haben und was sie voneinander unterscheidet. Wir wissen, dass sich diese Strukturen beliebig ineinander verschachteln lassen. Benannt nach Euklid von Alexandria, einem Mathematiker aus dem 3. Jahrhundert, Autor der Elemente - einem Kompendium des Wissens der Mathematik seiner Zeit. \u21a9","title":"Verschachteln von Kontrollstrukturen"},{"location":"aufgaben/","text":"Aufgaben \u00b6 Hier finden Sie die Aufgaben. Die Abgabefristen der einzelnen Aufgaben stehen hier . Beachten Sie die nachfolgenden Hinweise zum Hochladen der Aufgaben. Hinweise zur Abgabe der Aufgaben \u00b6 Die Aufgaben laden Sie in Moodle unter dem Reiter \"Aufgaben\" hoch. Dort ist f\u00fcr jede Aufgabe eine Moodle-Aufgabe erstellt. Beachten Sie, dass ein Hochladen nach Ablauf der Abgabefrist nicht mehr m\u00f6glich ist. Eclipse \u00b6 Sie sind in der Wahl Ihrer Entwicklungsumgebung frei. Ich verwende in der Veranstaltung Eclipse. Daf\u00fcr gelten die folgenden Hinweise: Achten Sie darauf, dass Sie die Quelldateien (also die .java -Dateien aus dem src -Verzeichnis) hochladen. Ihre Klassen erstellen Sie immer in einem package aufgaben.aufgabeX . Das hei\u00dft, Aufgabe1 ist im package aufgaben.aufgabe1 , Aufgabe2 im package aufgaben.aufgabe2 usw. In Ihrem workspace gibt es dann einen Ordner f\u00fcr Ihr Java-Projekt, z.B. WS22 (je nachdem, wie Sie Ihr Java-Projekt genannt haben) und darin befindet sich ein bin - und ein src -Ordner. In dem src -Ordner befindet sich dann ein Ordner aufgaben und darin ein Ordner aufgaben1 (f\u00fcr Aufgabe1). Darin befindet sich Ihre .java -Datei, die Sie hochladen sollen. Angenommen, Sie haben Ihre Klasse Aufgabe1 genannt, dann hei\u00dft die Klasse also Aufgabe1.java . Sie folgen also dem Pfad workspace \u2192 Java-Projekt (z.B. WS22 ) \u2192 src \u2192 aufgaben \u2192 aufgabe X . Wenn Ihre L\u00f6sung aus mehreren Klassen (mehreren .java -Dateien) besteht, k\u00f6nnen Sie entweder die Dateien einzeln hochladen oder Sie zippen Ihre Dateien (am besten dann den aufgabeX -Ordner und laden das .zip -File hoch. In Ihrer L\u00f6sung (Ihrer/n Klasse/n) f\u00fcgen Sie direkt oberhalb Ihrer Klassendefinition einen JavaDoc-Kommentar ein ( /** ... */ ). Dieser enth\u00e4lt ein @author -Tag. dahinter schreiben Sie Ihren Namen. Das sieht dann z.B. so aus: package aufgaben.aufgabe1 ; /** * * @author J\u00f6rn Freiheit * * Diese Klasse gibt auf die Konsole ein Rhombus (eine Raute) aus. * Der Rhombus ist entweder gefuellt oder ungefuellt. * */ public class Aufgabe1 { // hier Ihre Implementierung } Sie k\u00f6nnen Ihre Aufgaben zu zweit l\u00f6sen. Tragen Sie dann hinter das @author -Tag beide Namen ein und laden Sie bitte beide die L\u00f6sung in Moodle hoch! Code Review \u00b6 F\u00fcr jede abgegebene Aufgabe wird Ihnen die L\u00f6sung einer Kommilitonin zum Review zugewiesen. Analysieren Sie den Code Ihrer Kommilitonin und geben Sie ihr dazu eine R\u00fcckmeldung! Es gen\u00fcgen 2 bis 3 Review-Kommentare. Zur offiziellen Abgabe einer Aufgabe geh\u00f6ren also das Hochladen der eigenen L\u00f6sung, das Analysieren/Kommentieren einer fremden L\u00f6sung. Hinweise zum Review: \u00b6 Es geht nicht darum, das Programm zu \u00fcberarbeiten, sondern darum es nachzuvollziehen und Ihrer Kommilitonin eine R\u00fcckmeldung und eventuell Anregungen zu geben. Weisen Sie sowohl auf St\u00e4rken als auch auf Schw\u00e4chen des Quelltexts hin. Worauf Sie u.a. achten k\u00f6nnen: Ist der Quelltext gut strukturiert und verst\u00e4ndlich? Haben Variablen und Methoden passende Namen? Werden die Namen konsistent verwendet? Werden Konventionen eingehalten? Beispiel: Klassennamen starten immer mit Gro\u00dfbuchstaben, Objektnamen immer mit Kleinbuchstaben Ist das Programm \u00fcbersichtlich formatiert? Beispiel: kein horizontales Scrolling n\u00f6tig Machen Sie ggf. Vorschl\u00e4ge f\u00fcr (alternative) L\u00f6sungen. Gehen Sie respektvoll miteinander um, es gibt keinen Grund, unh\u00f6flich zu sein. Lesen Sie Ihre Kommentare noch einmal durch, bevor Sie sie an Ihre Kommilitonin weitergeben. Aufgaben \u00b6 Aufgabe 1 (Abgabe bis 24.10.2022 24:00 Uhr) \u00b6 Aufgabe 1 kommt in K\u00fcrze","title":"Aufgaben"},{"location":"aufgaben/#aufgaben","text":"Hier finden Sie die Aufgaben. Die Abgabefristen der einzelnen Aufgaben stehen hier . Beachten Sie die nachfolgenden Hinweise zum Hochladen der Aufgaben.","title":"Aufgaben"},{"location":"aufgaben/#hinweise-zur-abgabe-der-aufgaben","text":"Die Aufgaben laden Sie in Moodle unter dem Reiter \"Aufgaben\" hoch. Dort ist f\u00fcr jede Aufgabe eine Moodle-Aufgabe erstellt. Beachten Sie, dass ein Hochladen nach Ablauf der Abgabefrist nicht mehr m\u00f6glich ist.","title":"Hinweise zur Abgabe der Aufgaben"},{"location":"aufgaben/#eclipse","text":"Sie sind in der Wahl Ihrer Entwicklungsumgebung frei. Ich verwende in der Veranstaltung Eclipse. Daf\u00fcr gelten die folgenden Hinweise: Achten Sie darauf, dass Sie die Quelldateien (also die .java -Dateien aus dem src -Verzeichnis) hochladen. Ihre Klassen erstellen Sie immer in einem package aufgaben.aufgabeX . Das hei\u00dft, Aufgabe1 ist im package aufgaben.aufgabe1 , Aufgabe2 im package aufgaben.aufgabe2 usw. In Ihrem workspace gibt es dann einen Ordner f\u00fcr Ihr Java-Projekt, z.B. WS22 (je nachdem, wie Sie Ihr Java-Projekt genannt haben) und darin befindet sich ein bin - und ein src -Ordner. In dem src -Ordner befindet sich dann ein Ordner aufgaben und darin ein Ordner aufgaben1 (f\u00fcr Aufgabe1). Darin befindet sich Ihre .java -Datei, die Sie hochladen sollen. Angenommen, Sie haben Ihre Klasse Aufgabe1 genannt, dann hei\u00dft die Klasse also Aufgabe1.java . Sie folgen also dem Pfad workspace \u2192 Java-Projekt (z.B. WS22 ) \u2192 src \u2192 aufgaben \u2192 aufgabe X . Wenn Ihre L\u00f6sung aus mehreren Klassen (mehreren .java -Dateien) besteht, k\u00f6nnen Sie entweder die Dateien einzeln hochladen oder Sie zippen Ihre Dateien (am besten dann den aufgabeX -Ordner und laden das .zip -File hoch. In Ihrer L\u00f6sung (Ihrer/n Klasse/n) f\u00fcgen Sie direkt oberhalb Ihrer Klassendefinition einen JavaDoc-Kommentar ein ( /** ... */ ). Dieser enth\u00e4lt ein @author -Tag. dahinter schreiben Sie Ihren Namen. Das sieht dann z.B. so aus: package aufgaben.aufgabe1 ; /** * * @author J\u00f6rn Freiheit * * Diese Klasse gibt auf die Konsole ein Rhombus (eine Raute) aus. * Der Rhombus ist entweder gefuellt oder ungefuellt. * */ public class Aufgabe1 { // hier Ihre Implementierung } Sie k\u00f6nnen Ihre Aufgaben zu zweit l\u00f6sen. Tragen Sie dann hinter das @author -Tag beide Namen ein und laden Sie bitte beide die L\u00f6sung in Moodle hoch!","title":"Eclipse"},{"location":"aufgaben/#code-review","text":"F\u00fcr jede abgegebene Aufgabe wird Ihnen die L\u00f6sung einer Kommilitonin zum Review zugewiesen. Analysieren Sie den Code Ihrer Kommilitonin und geben Sie ihr dazu eine R\u00fcckmeldung! Es gen\u00fcgen 2 bis 3 Review-Kommentare. Zur offiziellen Abgabe einer Aufgabe geh\u00f6ren also das Hochladen der eigenen L\u00f6sung, das Analysieren/Kommentieren einer fremden L\u00f6sung.","title":"Code Review"},{"location":"aufgaben/#hinweise-zum-review","text":"Es geht nicht darum, das Programm zu \u00fcberarbeiten, sondern darum es nachzuvollziehen und Ihrer Kommilitonin eine R\u00fcckmeldung und eventuell Anregungen zu geben. Weisen Sie sowohl auf St\u00e4rken als auch auf Schw\u00e4chen des Quelltexts hin. Worauf Sie u.a. achten k\u00f6nnen: Ist der Quelltext gut strukturiert und verst\u00e4ndlich? Haben Variablen und Methoden passende Namen? Werden die Namen konsistent verwendet? Werden Konventionen eingehalten? Beispiel: Klassennamen starten immer mit Gro\u00dfbuchstaben, Objektnamen immer mit Kleinbuchstaben Ist das Programm \u00fcbersichtlich formatiert? Beispiel: kein horizontales Scrolling n\u00f6tig Machen Sie ggf. Vorschl\u00e4ge f\u00fcr (alternative) L\u00f6sungen. Gehen Sie respektvoll miteinander um, es gibt keinen Grund, unh\u00f6flich zu sein. Lesen Sie Ihre Kommentare noch einmal durch, bevor Sie sie an Ihre Kommilitonin weitergeben.","title":"Hinweise zum Review:"},{"location":"aufgaben/#aufgaben_1","text":"","title":"Aufgaben"},{"location":"aufgaben/#aufgabe-1-abgabe-bis-24102022-2400-uhr","text":"Aufgabe 1 kommt in K\u00fcrze","title":"Aufgabe 1 (Abgabe bis 24.10.2022 24:00 Uhr)"},{"location":"start/","text":"Unser erstes Programm \u00b6 Bevor wir uns mit der Funktionsweise von Java auseinandersetzen, schreiben wir einfach einmal unser erstes Programm. Wir \u00f6ffnen dazu Eclipse und erstellen uns eine Klasse HelloFIW . Dazu erstellen wir uns ein Java-Projekt (falls noch nicht geschehen): Men\u00fcpunkt File --> New --> Java Project , geben in das Textfeld Project name: z.B. WS22 ein. Den module name beim Erstellen der module-info.java k\u00f6nnen Sie genau so lassen, wie vorgeschlagen ( WS22 ). Klicken Sie auf den Button Create . erstellen wir uns ein Paket: Men\u00fcpunkt File --> New --> Package und geben themen.eins.start ein. erstellen wir uns eine Klasse: Wir w\u00e4hlen das Paket themen.eins.start aus und w\u00e4hlen den Men\u00fcpunkt File --> New --> Class , geben in dem Fenster den Klassennamen HelloFIW ein und setzen bei public static void main(Strg[] args) ein H\u00e4kchen: Im Editor-Fenster von Eclipse erscheint: HelloFIW.java 1 2 3 4 5 6 7 8 9 10 11 12 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { // TODO Auto-generated method stub } } Schauen wir uns diesen Code zun\u00e4chst an: in Zeile 1 sehen wir, in welchem Paket sich unsere Klasse befindet. Die Anweisung package themen.eins.start; definiert, dass wir uns im Paket themen.eins.start befinden. Mit Paketen werden wir uns in K\u00fcrze ausf\u00fchrlich auseinandersetzen. in Zeile 3 steht unsere Klassendefinition. Diese erkennen wir am Schl\u00fcsselwort class gefolgt von dem Namen der Klasse HelloFIW . Das Schl\u00fcsselwort public beschreibt, dass es sich um eine \u00f6ffentliche Klasse handelt, die von allen genutzt werden kann. Dieses Schl\u00fcsselwort ist ein sogenannter Sichtbarkeitsmodifierer (auch Zugriffsmodifizierer ). Mit Sichtbarkeitsmodifizierern werden wir uns ebenfalls noch ausf\u00fchrlich auseinandersetzen. Wichtig ist, dass die Klasse nicht nur aus dem Klassenkopf ( public class HelloFIW ) besteht, sondern aus allem, was diese Klassen enth\u00e4lt (dem Klassenrumpf). Der Klassenrumpf beginnt mit einer \u00f6ffnenden geschweiften Klammer { (Zeile 4 ) und endet mit einer schlie\u00dfenden geschweiften Klammer } (Zeile 12 ). eine Klasse kann beliebig viele Methoden enthalten. Unsere Klasse enth\u00e4lt bis jetzt eine Methode, die Methode namens main() . Methoden erkennen wir an den runden Klammern nach dem Methodennamen. Hier ist der Name main gefolgt von runden Klammern, in denen Parameter (auch Argumente genannt) definiert sein k\u00f6nnen (hier ein Parameter namens args vom Typ String-Array: Strg[] args ). Wie bei den Klassen auch, bestehen Methoden aus einem Methodenkopf und einem Methodenrumpf. Wie bei den Klassen auch, beginnt der Methodenrumpf mit einer \u00f6ffnenden geschweiften Klammer (Zeile 7 ) und endet mit einer schlie\u00dfenden geschweiften Klammer (Zeile 10 ). Der Methodenkopf beginnt erneut mit einem Sichtbarkeitsmodifizierer. Dieser ist hier wieder public und gibt an, dass diese Methode \u00f6ffentlich ist und von allen ausgef\u00fchrt werden kann. Danach kommt das Schl\u00fcsselwort static . Dieses Schl\u00fcsselwort besagt, dass es sich bei dieser Methode um eine Klassenmethode handelt. Das Gegenst\u00fcck zu einer Klassenmethode ist die Objektmethode . Wir werden uns mit der Unterscheidung zwischen Klassen- und Objektmnethoden ausf\u00fchrlich auseinandersetzen. Wir k\u00f6nnen uns aber schon merken (wenn \u00fcberhaupt), dass wir eine Klassenmethode aufrufen k\u00f6nnen ohne ein Objekt der Klasse erstellen zu m\u00fcssen. Danach kommt das Schl\u00fcsselwort void . Dieses Schl\u00fcsslwort gibt an, dass die Methode nichts zur\u00fcckgibt. An dieser Stelle steht der R\u00fcckgabetyp eine Methode - wenn die Methode etwas zur\u00fcckgibt. Unsere Methode gibt nichts zur\u00fcck, deshalb hier void . Wir werden uns mit Methodenr\u00fcckgaben ausf\u00fchrlich besch\u00e4ftigen. Jetzt kommt der Name der Methode, hier main . Die main() -Methode ist eine ganz besondere Methode. Sie existiert in einem Programm genau einmal und wird aufgerufen, wenn das Programm aufgerufen wird - die sogenannte Programmmethode . Wenn wir ein Programm ausf\u00fchren, wird alles das ausgef\u00fchrt, was in dem Rumpf der main() -Methode definiert ist (derzeit noch nichts). In den runden Klammern stehen Parameter (auch Argumente genannt). In unserem Fall ist ein Parameter namens args definiert. Der Datentyp dieses Parameters ist Strg[] , d.h. dass der Parameter einem Array von Zeichenketten Strings entspricht. Wir k\u00fcmmern uns um Parameter sp\u00e4ter ausf\u00fchrlich. In unserer Methode gibt es derzeit nur einen einzigen Eintrag (Zeile 8 ). Dabei handelt es sich um einen Kommentar , genauer hier um einen Zeilenkommentar . Zeilenkommentare beginnen mit einem Doppelslash // . Hinter diesen Doppelslash k\u00f6nnen Sie schreiben, was Sie m\u00f6chten - bis an das Zeilenende. Kommentare dienen Ihnen dazu, den Code verst\u00e4ndlicher zu gestalten oder Ihnen Hinweise zu geben. Hier steht der Hinweis, dass die Methode automatisch durch Eclipse erstellt wurde und Sie noch das ToDo haben, die Methode zu bef\u00fcllen. Das machen wir jetzt auch! Wir l\u00f6schen den Kommentar und f\u00fcgen nun die Anweisung System.out.println(\"HelloFIW !\"); in unseren Methodenrumpf ein. Unsere Klasse sieht nun so aus (die neuhinzugekommene Zeile ist markiert): HelloFIW.java 1 2 3 4 5 6 7 8 9 10 11 12 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { System . out . println ( \"Hello FIW!\" ); } } Jetzt w\u00e4hlen wir entweder im Men\u00fc Run --> Run oder klicken auf den kleinen gr\u00fcnen Kreis mit dem wei\u00dfen Pfeil in der Mitte in der Werkzeugleiste. Sie werden gefragt, ob Sie Ihr Programm zun\u00e4chst speichern wollen. Bevor Sie das best\u00e4tigen, sollten Sie ein H\u00e4kchen setzen, um zu sagen, dass Sie das gar nicht mehr gefragt werden wollen, sondern das Programm immer gespeichert werden soll, bevor Sie es ausf\u00fchren. In der Konsole erscheint: Success Herzlichen Gl\u00fcckwunsch! Sie haben Ihr erstes Java-Programm geschrieben und ausgef\u00fchrt! System.out.println(\"Hello FIW!\"); \u00b6 Schauen wir uns System.out.println(\"Hello FIW!\"); zun\u00e4chst etwas genauer an. Wir verwenden hier eine Klasse, n\u00e4mlcih die Klasse System . Diese Klasse existiert bereits und wurde von den Java-Entwicklern f\u00fcr uns gesschrieben. Sie geh\u00f6rt zum Standardpaket von Java, existiert bereits seit der ersten Version von Java und befindet sich im Paket java.lang . Diese Klasse hat eine interssante Klassenvariable, die wir verwenden, n\u00e4mlich out . Diese Variable stellt in unserem (Betriebs-)System die Verbindung zu unserem Standardausgabeger\u00e4t bereit, in unserem Fall die Konsole. Um nun eine Ausgabe auf diese Konsole zu generieren verwenden wir die Methode println() . Wir sehen hier eine typische Notation in Java, die sogenannte Punktnotation . Mithilfe dieser Punktnotation greifen wir auf Eigenschaften von Klassen und Objekten zu. In unserem Beispiel greifen wir mit System.out auf das Standardausgabeger\u00e4t zu und mit System.out.println() auf die println() -Methode des Ausgabeger\u00e4tes 1 . Die Methode println() erzeugt also eine Ausgabe auf unsere Konsole. Jetzt m\u00fcssen wir nur noch sagen, WAS ausgegeben werden sollen. Dazu \u00fcbergeben wir dieser Methode eine Zeichenkette (einen String ). Eine Zeichenkette erkennt man an den doppelten Anf\u00fchrungsstrichen \"das ist eine Zeichekette\" . Innerhalb dieser Anf\u00fchrungsstriche k\u00f6nnen Sie schreiben, was Sie m\u00f6chten (au\u00dfer \" ). Wir haben uns f\u00fcr \"Hello FIW!\" entschieden und genau diese Zeichenkette (ohne die Anf\u00fchrungsstriche) wird ausgegeben. Die Zeichnkette, die wir ausgeben m\u00f6chten, schreiben wir in die runden Klammern der println() -Methode, also println(\"Hello FIW!\") . Bei System.out.println(\"Hello FIW!\"); handelt es sich um eine Anweisung . Eine Anweisung endet in Java immer mit einem Semikolon ; . Dieses d\u00fcrfen wir nicht vergessen, ansonsten haben wir einen Syntaxfehler und unser Programm kann nicht compiliert und nicht ausgef\u00fchrt werden. Tipp Wir m\u00fcssen System.out.println() von nun an recht h\u00e4ufig schreiben. Deshalb gibt es in Eclipse daf\u00fcr einen Shortcut. Schreiben Sie einfach syso und klicken dann die Control ( Strg )-Taste zusammen mit der Leertaste und dann Enter . Aus dem syso macht Eclipse dann automatisch System.out.println() . Das hei\u00dft, dass jede der Ausgaben mithilfe der println() -Methode in einer neuen Zeile erfolgt. Nach jeder Ausgabe erfolgt also ein Zeilenumbruch, der Ausgabecursor wird in die n\u00e4chste Zeile gesetzt. Die n\u00e4chste Ausgabe beginnt am Anfang der neuen Zeile. Wir wollen nun unser Programm \u00e4ndern und verwenden nicht mehr die println() - Methode, sondern print() : main()-Methode mit print() 1 2 3 4 5 6 7 8 9 10 11 12 13 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { System . out . print ( \"Hello FIW!\" ); System . out . print ( \"Hello FIW!\" ); System . out . print ( \"Hello FIW!\" ); } } Wir f\u00fchren das Programm erneut aus (gr\u00fcner Pfeil ) und erhalten auf der Konsole die Ausgabe: Hello FIW!Hello FIW!Hello FIW! Die print() -Methode gibt also nur die Zeichenkette aus, f\u00fchrt aber danach keinen Zeilenumbruch durch. Der Ausgabecursor bleibt hinter dem letzten ausgegebenen Zeichen stehen. Unsere drei Zeichenketten werden in der Konsole deshalb hintereinander ausgegeben. \u00dcbung Was m\u00fcssen Sie im Programm \u00e4ndern, damit zwischen ! und H jeweils ein Leerzeichen ist, also anstelle von Hello FIW!Hello FIW!Hello FIW! besser Hello FIW! Hello FIW! Hello FIW! ausgegeben wird? Wir \u00e4ndern nun unser Programm erneut und f\u00fcgen folgende Anweisungen hinzu: System.out.println() . Wir rufen also die println() -Methode auf, ohne eine Zeichenkette zu \u00fcbergeben, die ausgegeben werden soll. Diese Anweisung sorgt einfach daf\u00fcr, dass ein Zeilenumbruch erfolgt. Es wird also nichts ausgegeben, aber der Ausgabecursor an den Beginn der n\u00e4chsten Zeile gesetzt. main()-Methode mit print() und println() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { System . out . print ( \"Hello FIW!\" ); System . out . println (); System . out . print ( \"Hello FIW!\" ); System . out . println (); System . out . print ( \"Hello FIW!\" ); System . out . println (); } } Wir f\u00fchren das Programm erneut aus (gr\u00fcner Pfeil ) und erhalten auf der Konsole die Ausgabe: Hello FIW! Hello FIW! Hello FIW! \u00dcbung Erzeugen Sie folgende Ausgabe auf der Konsole: Hello FIW! Hello FIW! Hello FIW! Eine m\u00f6gliche L\u00f6sung 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { System . out . println ( \"Hello FIW!\" ); System . out . println (); System . out . println ( \"Hello FIW!\" ); System . out . println (); System . out . println ( \"Hello FIW!\" ); System . out . println (); } } Syntaxfehler \u00b6 Programmieren bedeutet auch, Fehler zu machen. Wichtig ist, dass Sie die Fehlerausschriften lesen und die Fehler analysieren. Haben Sie einen Syntaxfehler, so ist ein Bereich Ihres Programmcodes rot unterstrichen und an der Seite erscheint ein rotes Kreuz. Fahren Sie mit der Maus \u00fcber das rote Kreuz, um die Fehlerausschrift zu erhalten. Bei einem Syntaxfehler l\u00e4sst sich das Programm nicht compilieren. Sie k\u00f6nnen es trotzdem versuchen und erhalten die Fehlerausschrift dann auf der Konsole. Das folgende Bild zeigt einen Fehler: Es erscheint die Fehlermeldung Syntax error, insert \";\" to complete BlockStatements - ein Hinweis darauf, dass ein Semikolon fehlt - n\u00e4mlcih am Ende der Anweisung. In vielen F\u00e4llen bietet Eclipse einen sogenannten Quickfix an. Meistens k\u00f6nnen Sie diesen Vorschlag einfach annehmen (durch Mausclick auf den Vorschlag). Die folgende Abbildung zeigt einen solchen Quickfix f\u00fcr den Fehler, dass die Methode prntln() nicht existiert (es fehlt das i ). Success Wir haben unser erstes Java-Programm geschrieben und ausgef\u00fchrt! Wir haben gelernt, wie wir mithilfe der Methoden println() und print() Zeichenketten auf die Konsole ausgeben k\u00f6nnen und wir haben uns angeschaut, wie wir Fehlerausschriften lesen. Nun schauen wir uns einmal an, was im Hintergrund passiert, wenn wir das Programm ausf\u00fchren. Kommentare \u00b6 In Ihren Quellcode (Ihr Programm) k\u00f6nnen Sie an allen beliebigen Stellen Kommentare schreiben. Kommentare werden vom Compiler ignoriert, d.h. Sie k\u00f6nnen dort hineinschreiben, was und wie Sie m\u00f6chten. Es gibt drei Arten von Kommentaren in Java: Zeilenkommentare : Diese beginnen mit // und danach kommt der Kommentar bis zum Zeilenende. Die neue Zeile ist dann wieder \"normaler\" Quellcode System . out . println ( \"Ausgabe1\" ); // hier ist ein Zeilenkommentar bis zum Ende der Zeile System . out . println ( \"Ausgabe2\" ); // hier ist noch ein Zeilenkommentar Blockkommentare : Diese beginnen mit /* und danach kommt der Kommentar. Er kann sich \u00fcber mehrere Zeilen erstrecken. Ein Blockkommentar endet mit */ . Nach diesem Ende ist sofort wieder \"normaler\" Quellcode. System . out . println ( \"Ausgabe1\" ); /* hier ist ein Blockkommentar er kann \u00fcber beliebig viele Zeilen gehen Er endet erst mit */ System . out . println ( \"Ausgabe2\" ); Java-Doc-Kommentare : javadoc ist ein Programm aus dem Java Development Kit (JDK) . Es wird eingesetzt, um den Code zu dokumentieren. Wir werden javadoc noch ausf\u00fchrlich behandeln. Mit javadoc kommentierte Klassen finden Sie hier . Java-Doc-Kommentare beginnen mit /** und enden mit */ . Java-Doc-Kommentare verhalten sich wie Blockkommentare. Sie erstrecken sich \u00fcber mehrere Zeilen und nach dem */ ist, wie bei Blockkommentaren, wieder \"normaler\" Quellcode. package uebungen.uebung0 ; /** * * @author jornfreiheit * * Das ist die erste Klasse, die wir geschrieben haben. * Sie erzeugt einfache Ausgaben von Zeichenketten auf * die Konsole. * */ public class MyFirstClass { // Hier die Implementierung unserer Klasse - nicht gezeigt } Compilieren und Ausf\u00fchren \u00b6 Wir haben nun unser erstes einfaches Programm geschrieben - in der Programmiersprache Java . Wie wir in Werkzeuge -> Java bereits bei der Installation von Java erl\u00e4utert haben, ist Java nicht nur eine Programmiersprache, sondern auch ein Programm, in dem wir Java-Programme ausf\u00fchren k\u00f6nnen - die Laufzeitumgebung von Java. Wir werden zun\u00e4chst erl\u00e4utern, was im Hintergrund passiert, wenn wir ein selbstgeschriebenes Java-Programm ausf\u00fchren. Zum besseren Verst\u00e4ndnis erzeugen wir uns zun\u00e4chst ein Verzeichnis test irgendwo auf unserem Rechner: mkdir test cd test Dieses Verzeichnis werden wir sp\u00e4ter wieder l\u00f6schen. Nun erzeugen wir uns mithilfe von vi oder vim eine Datei Test.java : vim Test.java Die Datei \u00f6ffnet sich zum Schreiben und nach Eingabe von i k\u00f6nnen wir in diese Datei Text einf\u00fcgen. Wir f\u00fcgen folgendes Programm ein (Kopieren Sie das Programm und f\u00fcgen es mit Strg+V in die Datei Test.java ein: Test.java 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test { public static void main ( String [] args ) { System . out . print ( \"Hello \" ); for ( String s : args ) { System . out . print ( s + \" \" ); } System . out . println ( \"!\" ); } } Beenden Sie den Einf\u00fcgemodus von vim durch Dr\u00fccken der Taste Esc und speichern die Datei und beenden vim unter Eingabe von ZZ . In unserem Ordner test befindet sich nun die Datei Test.java : ls -la zeigt den Inhalt unseres Verzeichnisses test an (z.B.): total 8 drwxr-xr-x@ 3 jornfreiheit staff 96 3 Aug 14 :17 . drwxr-xr-x@ 39 jornfreiheit staff 1248 1 Nov 2018 .. -rw-r--r-- 1 jornfreiheit staff 189 3 Aug 14 :17 Test.java Wir haben eine Klasse Test in der Datei erstellt, die genauso hei\u00dft, wie die Klasse, n\u00e4mlich Test.java . Wir werden in Zukunft immer die Klasse in der gleichnamigen Datei speichern, die die Dateiendung .java hat - das macht Eclipse f\u00fcr uns automatisch. Compilieren der Klasse \u00b6 Ein Computer kann keine Datei ausf\u00fchren, die in einer Programmiersprache geschrieben wurde, egal um welche Programmiersprache es sich handelt. Computer verstehen nur Folgen von Nullen und Einsen, also so etwas wie 1000111110101011... . In eine solche Maschinensprache muss unser Programm \u00fcbersetzt werden. Das \u00dcbersetzen erfolgt durch einen Compiler 2 . Der Java-Compiler hei\u00dft javac . Wir haben den Java-Compiler zusammen mit dem Java Development Kit (JDK) installiert (siehe hier ). Mithilfe des Compilers \u00fcbersetzen wir nun unsere Klasse: javac Test . java Wenn wir uns nun erneut den Inhalt unseres Verzeichnisses ansehen ls -la dann entdecken wir, dass eine Datei Test.class erzeugt wurde. total 16 drwxr-xr-x@ 4 jornfreiheit staff 128 7 Aug 11 :02 . drwxr-xr-x@ 39 jornfreiheit staff 1248 1 Nov 2018 .. -rw-r--r-- 1 jornfreiheit staff 1001 7 Aug 11 :02 Test.class -rw-r--r-- 1 jornfreiheit staff 189 3 Aug 14 :17 Test.java Unser Java-Compiler hat unser Programm, das in Test.java enthalten ist, in sogenannten Bytecode \u00fcbersetzt. Das ist ein Zwischenschritt, den es in Java gibt. Das Programm wird nicht direkt in Maschinencode \u00fcbersetzt, sondern in Bytecode. Ausf\u00fchren des Programms \u00b6 Dieser Bytecode kann nun von der Java-Laufzeitumgebung (Java Runtime Environment - JRE) ausgef\u00fchrt werden. Diese Laufzeitumgebung ist selbst ein Programm, eine sogenannte Virtuelle Maschine 3 . Die Ausf\u00fchrung unseres Programms erfolgt mithilfe der Java-Laufzeitumgebung java : java Test Beachten Sie, dass Sie nicht die Dateiendung .class f\u00fcr Ihr Programm angeben (m\u00fcssen/d\u00fcrfen). Auf unserer Konsole erscheint die Ausgabe Hello ! Diese Ausgabe erfolgt durch die Anweisung System.out.print(\"Hello \"); (in Zeile 6 ), gefolgt von der Anweisung System.out.println(\"!\"); (in Zeile 11 ). In den Zeilen 7 - 10 stehen Anweisungen, die wir noch nicht verstehen. Das macht nichts, wir kommen sp\u00e4ter darauf zur\u00fcck. Es ist jedoch so, dass wir dadurch unserem Programm Argumente \u00fcbergeben k\u00f6nnen. Betrac hten wir zum Beispiel die Anweisung ls -la . ls w\u00e4re z.B. ein \"Programm\" und -la ein Argument ( -l sorgt daf\u00fcr, dass ein langes Listenformat erscheint, also alle Angaben zu den Dateien und Ordnern erscheinen und -a sorgt daf\u00fcr, dass auch die Dateien und Ordner angezeigt werden, die mit . beginnen). Versuchen wir also einmal, umserem Programm Test ein Argument zu \u00fcbergeben (ohne - ): java Test FIW Es erscheint die Ausgabe: Hello FIW ! Wir k\u00f6nnen sogar mehrere Argumente \u00fcbergeben: java Test FIW HTW Berlin Welt Es erscheint die Ausgabe: Hello FIW HTW Berlin Welt ! Es erscheint zun\u00e4chst aufwendig, das Programm zun\u00e4chst in Bytecode zu \u00fcbersetzen und dann den Bytecode nochmal interpretieren und ausf\u00fchren zu lassen. Warum wird nicht direkt in Maschinencode \u00fcbersetzt? Die Antwort ist, dass der Java-Compiler so beriebssystemunabh\u00e4ngig arbeiten kann. Alle, egal, ob Windows-, iOS- oder Linux-Nutzerinnen k\u00f6nnen den gleichen Compiler verwenden. Die Programme k\u00f6nnen v\u00f6llig systemunabh\u00e4ngig geschrieben und von allen compiliert werden. Erst die Java-Laufzeitumgebung ist beriebssystemabh\u00e4ngig, d.h. diese wird entsprechend dem Betriebssystem installiert. Alle Java-Programme und auch ihre Compilierung sind jedoch v\u00f6llig losgel\u00f6st vom verwendeten Betriebssystem und k\u00f6nnen deshalb \u00fcberall ausgef\u00fchrt werden. Success Wir haben uns angeschaut, was passiert, wenn wir das Programm \u00fcbersetzen und ausf\u00fchren. Die \u00dcbersetzung erfolgt durch den Java-Compiler javac . Dieser erzeugt Java-Bytecode . Die Ausf\u00fchrung dieses Bytcodes \u00fcbernimmt die Java-Laufzeitumgebung java . Diese interpretiert den Bytecode und f\u00fchrt ihn sequentiell (also nacheinander, Anweisung f\u00fcr Anweisung) aus. Wenn wir ganz genau sein wollen, dann ist out vom Typ PrintStream und wir greifen auf die Objektmethode println() des PrintStream -Objektes out zu. \u21a9 Man unterscheidet bei Programmiersprachen, ob die Programme durch einen Compiler oder durch einen Interpreter \u00fcbersetzt werden. Programmiersprachen, bei denen die Programme durch einen Interpreter \u00fcbersetzt werden, werden auch Skriptsprachen genannt. In Skriptsprachen wird jede einzelne Anweisung nach und nach interpretiert , d.h. \u00fcbersetzt, dann ausgef\u00fchrt, dann die n\u00e4chste Anweisung \u00fcbersetzt, ausgef\u00fchrt usw. Java-Programme werden compiliert, d.h. sie werden als Ganzes \u00fcbersetzt und erst dann ausgef\u00fchrt. \u21a9 Genauer handelt es sich dabei um einen Interpreter . Der Java-Bytecode wird Anweisung f\u00fcr Anweisung interpretiert und ausgef\u00fchrt. \u21a9","title":"Erstes Programm"},{"location":"start/#unser-erstes-programm","text":"Bevor wir uns mit der Funktionsweise von Java auseinandersetzen, schreiben wir einfach einmal unser erstes Programm. Wir \u00f6ffnen dazu Eclipse und erstellen uns eine Klasse HelloFIW . Dazu erstellen wir uns ein Java-Projekt (falls noch nicht geschehen): Men\u00fcpunkt File --> New --> Java Project , geben in das Textfeld Project name: z.B. WS22 ein. Den module name beim Erstellen der module-info.java k\u00f6nnen Sie genau so lassen, wie vorgeschlagen ( WS22 ). Klicken Sie auf den Button Create . erstellen wir uns ein Paket: Men\u00fcpunkt File --> New --> Package und geben themen.eins.start ein. erstellen wir uns eine Klasse: Wir w\u00e4hlen das Paket themen.eins.start aus und w\u00e4hlen den Men\u00fcpunkt File --> New --> Class , geben in dem Fenster den Klassennamen HelloFIW ein und setzen bei public static void main(Strg[] args) ein H\u00e4kchen: Im Editor-Fenster von Eclipse erscheint: HelloFIW.java 1 2 3 4 5 6 7 8 9 10 11 12 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { // TODO Auto-generated method stub } } Schauen wir uns diesen Code zun\u00e4chst an: in Zeile 1 sehen wir, in welchem Paket sich unsere Klasse befindet. Die Anweisung package themen.eins.start; definiert, dass wir uns im Paket themen.eins.start befinden. Mit Paketen werden wir uns in K\u00fcrze ausf\u00fchrlich auseinandersetzen. in Zeile 3 steht unsere Klassendefinition. Diese erkennen wir am Schl\u00fcsselwort class gefolgt von dem Namen der Klasse HelloFIW . Das Schl\u00fcsselwort public beschreibt, dass es sich um eine \u00f6ffentliche Klasse handelt, die von allen genutzt werden kann. Dieses Schl\u00fcsselwort ist ein sogenannter Sichtbarkeitsmodifierer (auch Zugriffsmodifizierer ). Mit Sichtbarkeitsmodifizierern werden wir uns ebenfalls noch ausf\u00fchrlich auseinandersetzen. Wichtig ist, dass die Klasse nicht nur aus dem Klassenkopf ( public class HelloFIW ) besteht, sondern aus allem, was diese Klassen enth\u00e4lt (dem Klassenrumpf). Der Klassenrumpf beginnt mit einer \u00f6ffnenden geschweiften Klammer { (Zeile 4 ) und endet mit einer schlie\u00dfenden geschweiften Klammer } (Zeile 12 ). eine Klasse kann beliebig viele Methoden enthalten. Unsere Klasse enth\u00e4lt bis jetzt eine Methode, die Methode namens main() . Methoden erkennen wir an den runden Klammern nach dem Methodennamen. Hier ist der Name main gefolgt von runden Klammern, in denen Parameter (auch Argumente genannt) definiert sein k\u00f6nnen (hier ein Parameter namens args vom Typ String-Array: Strg[] args ). Wie bei den Klassen auch, bestehen Methoden aus einem Methodenkopf und einem Methodenrumpf. Wie bei den Klassen auch, beginnt der Methodenrumpf mit einer \u00f6ffnenden geschweiften Klammer (Zeile 7 ) und endet mit einer schlie\u00dfenden geschweiften Klammer (Zeile 10 ). Der Methodenkopf beginnt erneut mit einem Sichtbarkeitsmodifizierer. Dieser ist hier wieder public und gibt an, dass diese Methode \u00f6ffentlich ist und von allen ausgef\u00fchrt werden kann. Danach kommt das Schl\u00fcsselwort static . Dieses Schl\u00fcsselwort besagt, dass es sich bei dieser Methode um eine Klassenmethode handelt. Das Gegenst\u00fcck zu einer Klassenmethode ist die Objektmethode . Wir werden uns mit der Unterscheidung zwischen Klassen- und Objektmnethoden ausf\u00fchrlich auseinandersetzen. Wir k\u00f6nnen uns aber schon merken (wenn \u00fcberhaupt), dass wir eine Klassenmethode aufrufen k\u00f6nnen ohne ein Objekt der Klasse erstellen zu m\u00fcssen. Danach kommt das Schl\u00fcsselwort void . Dieses Schl\u00fcsslwort gibt an, dass die Methode nichts zur\u00fcckgibt. An dieser Stelle steht der R\u00fcckgabetyp eine Methode - wenn die Methode etwas zur\u00fcckgibt. Unsere Methode gibt nichts zur\u00fcck, deshalb hier void . Wir werden uns mit Methodenr\u00fcckgaben ausf\u00fchrlich besch\u00e4ftigen. Jetzt kommt der Name der Methode, hier main . Die main() -Methode ist eine ganz besondere Methode. Sie existiert in einem Programm genau einmal und wird aufgerufen, wenn das Programm aufgerufen wird - die sogenannte Programmmethode . Wenn wir ein Programm ausf\u00fchren, wird alles das ausgef\u00fchrt, was in dem Rumpf der main() -Methode definiert ist (derzeit noch nichts). In den runden Klammern stehen Parameter (auch Argumente genannt). In unserem Fall ist ein Parameter namens args definiert. Der Datentyp dieses Parameters ist Strg[] , d.h. dass der Parameter einem Array von Zeichenketten Strings entspricht. Wir k\u00fcmmern uns um Parameter sp\u00e4ter ausf\u00fchrlich. In unserer Methode gibt es derzeit nur einen einzigen Eintrag (Zeile 8 ). Dabei handelt es sich um einen Kommentar , genauer hier um einen Zeilenkommentar . Zeilenkommentare beginnen mit einem Doppelslash // . Hinter diesen Doppelslash k\u00f6nnen Sie schreiben, was Sie m\u00f6chten - bis an das Zeilenende. Kommentare dienen Ihnen dazu, den Code verst\u00e4ndlicher zu gestalten oder Ihnen Hinweise zu geben. Hier steht der Hinweis, dass die Methode automatisch durch Eclipse erstellt wurde und Sie noch das ToDo haben, die Methode zu bef\u00fcllen. Das machen wir jetzt auch! Wir l\u00f6schen den Kommentar und f\u00fcgen nun die Anweisung System.out.println(\"HelloFIW !\"); in unseren Methodenrumpf ein. Unsere Klasse sieht nun so aus (die neuhinzugekommene Zeile ist markiert): HelloFIW.java 1 2 3 4 5 6 7 8 9 10 11 12 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { System . out . println ( \"Hello FIW!\" ); } } Jetzt w\u00e4hlen wir entweder im Men\u00fc Run --> Run oder klicken auf den kleinen gr\u00fcnen Kreis mit dem wei\u00dfen Pfeil in der Mitte in der Werkzeugleiste. Sie werden gefragt, ob Sie Ihr Programm zun\u00e4chst speichern wollen. Bevor Sie das best\u00e4tigen, sollten Sie ein H\u00e4kchen setzen, um zu sagen, dass Sie das gar nicht mehr gefragt werden wollen, sondern das Programm immer gespeichert werden soll, bevor Sie es ausf\u00fchren. In der Konsole erscheint: Success Herzlichen Gl\u00fcckwunsch! Sie haben Ihr erstes Java-Programm geschrieben und ausgef\u00fchrt!","title":"Unser erstes Programm"},{"location":"start/#systemoutprintlnhello-fiw","text":"Schauen wir uns System.out.println(\"Hello FIW!\"); zun\u00e4chst etwas genauer an. Wir verwenden hier eine Klasse, n\u00e4mlcih die Klasse System . Diese Klasse existiert bereits und wurde von den Java-Entwicklern f\u00fcr uns gesschrieben. Sie geh\u00f6rt zum Standardpaket von Java, existiert bereits seit der ersten Version von Java und befindet sich im Paket java.lang . Diese Klasse hat eine interssante Klassenvariable, die wir verwenden, n\u00e4mlich out . Diese Variable stellt in unserem (Betriebs-)System die Verbindung zu unserem Standardausgabeger\u00e4t bereit, in unserem Fall die Konsole. Um nun eine Ausgabe auf diese Konsole zu generieren verwenden wir die Methode println() . Wir sehen hier eine typische Notation in Java, die sogenannte Punktnotation . Mithilfe dieser Punktnotation greifen wir auf Eigenschaften von Klassen und Objekten zu. In unserem Beispiel greifen wir mit System.out auf das Standardausgabeger\u00e4t zu und mit System.out.println() auf die println() -Methode des Ausgabeger\u00e4tes 1 . Die Methode println() erzeugt also eine Ausgabe auf unsere Konsole. Jetzt m\u00fcssen wir nur noch sagen, WAS ausgegeben werden sollen. Dazu \u00fcbergeben wir dieser Methode eine Zeichenkette (einen String ). Eine Zeichenkette erkennt man an den doppelten Anf\u00fchrungsstrichen \"das ist eine Zeichekette\" . Innerhalb dieser Anf\u00fchrungsstriche k\u00f6nnen Sie schreiben, was Sie m\u00f6chten (au\u00dfer \" ). Wir haben uns f\u00fcr \"Hello FIW!\" entschieden und genau diese Zeichenkette (ohne die Anf\u00fchrungsstriche) wird ausgegeben. Die Zeichnkette, die wir ausgeben m\u00f6chten, schreiben wir in die runden Klammern der println() -Methode, also println(\"Hello FIW!\") . Bei System.out.println(\"Hello FIW!\"); handelt es sich um eine Anweisung . Eine Anweisung endet in Java immer mit einem Semikolon ; . Dieses d\u00fcrfen wir nicht vergessen, ansonsten haben wir einen Syntaxfehler und unser Programm kann nicht compiliert und nicht ausgef\u00fchrt werden. Tipp Wir m\u00fcssen System.out.println() von nun an recht h\u00e4ufig schreiben. Deshalb gibt es in Eclipse daf\u00fcr einen Shortcut. Schreiben Sie einfach syso und klicken dann die Control ( Strg )-Taste zusammen mit der Leertaste und dann Enter . Aus dem syso macht Eclipse dann automatisch System.out.println() . Das hei\u00dft, dass jede der Ausgaben mithilfe der println() -Methode in einer neuen Zeile erfolgt. Nach jeder Ausgabe erfolgt also ein Zeilenumbruch, der Ausgabecursor wird in die n\u00e4chste Zeile gesetzt. Die n\u00e4chste Ausgabe beginnt am Anfang der neuen Zeile. Wir wollen nun unser Programm \u00e4ndern und verwenden nicht mehr die println() - Methode, sondern print() : main()-Methode mit print() 1 2 3 4 5 6 7 8 9 10 11 12 13 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { System . out . print ( \"Hello FIW!\" ); System . out . print ( \"Hello FIW!\" ); System . out . print ( \"Hello FIW!\" ); } } Wir f\u00fchren das Programm erneut aus (gr\u00fcner Pfeil ) und erhalten auf der Konsole die Ausgabe: Hello FIW!Hello FIW!Hello FIW! Die print() -Methode gibt also nur die Zeichenkette aus, f\u00fchrt aber danach keinen Zeilenumbruch durch. Der Ausgabecursor bleibt hinter dem letzten ausgegebenen Zeichen stehen. Unsere drei Zeichenketten werden in der Konsole deshalb hintereinander ausgegeben. \u00dcbung Was m\u00fcssen Sie im Programm \u00e4ndern, damit zwischen ! und H jeweils ein Leerzeichen ist, also anstelle von Hello FIW!Hello FIW!Hello FIW! besser Hello FIW! Hello FIW! Hello FIW! ausgegeben wird? Wir \u00e4ndern nun unser Programm erneut und f\u00fcgen folgende Anweisungen hinzu: System.out.println() . Wir rufen also die println() -Methode auf, ohne eine Zeichenkette zu \u00fcbergeben, die ausgegeben werden soll. Diese Anweisung sorgt einfach daf\u00fcr, dass ein Zeilenumbruch erfolgt. Es wird also nichts ausgegeben, aber der Ausgabecursor an den Beginn der n\u00e4chsten Zeile gesetzt. main()-Methode mit print() und println() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { System . out . print ( \"Hello FIW!\" ); System . out . println (); System . out . print ( \"Hello FIW!\" ); System . out . println (); System . out . print ( \"Hello FIW!\" ); System . out . println (); } } Wir f\u00fchren das Programm erneut aus (gr\u00fcner Pfeil ) und erhalten auf der Konsole die Ausgabe: Hello FIW! Hello FIW! Hello FIW! \u00dcbung Erzeugen Sie folgende Ausgabe auf der Konsole: Hello FIW! Hello FIW! Hello FIW! Eine m\u00f6gliche L\u00f6sung 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { System . out . println ( \"Hello FIW!\" ); System . out . println (); System . out . println ( \"Hello FIW!\" ); System . out . println (); System . out . println ( \"Hello FIW!\" ); System . out . println (); } }","title":"System.out.println(\"Hello FIW!\");"},{"location":"start/#syntaxfehler","text":"Programmieren bedeutet auch, Fehler zu machen. Wichtig ist, dass Sie die Fehlerausschriften lesen und die Fehler analysieren. Haben Sie einen Syntaxfehler, so ist ein Bereich Ihres Programmcodes rot unterstrichen und an der Seite erscheint ein rotes Kreuz. Fahren Sie mit der Maus \u00fcber das rote Kreuz, um die Fehlerausschrift zu erhalten. Bei einem Syntaxfehler l\u00e4sst sich das Programm nicht compilieren. Sie k\u00f6nnen es trotzdem versuchen und erhalten die Fehlerausschrift dann auf der Konsole. Das folgende Bild zeigt einen Fehler: Es erscheint die Fehlermeldung Syntax error, insert \";\" to complete BlockStatements - ein Hinweis darauf, dass ein Semikolon fehlt - n\u00e4mlcih am Ende der Anweisung. In vielen F\u00e4llen bietet Eclipse einen sogenannten Quickfix an. Meistens k\u00f6nnen Sie diesen Vorschlag einfach annehmen (durch Mausclick auf den Vorschlag). Die folgende Abbildung zeigt einen solchen Quickfix f\u00fcr den Fehler, dass die Methode prntln() nicht existiert (es fehlt das i ). Success Wir haben unser erstes Java-Programm geschrieben und ausgef\u00fchrt! Wir haben gelernt, wie wir mithilfe der Methoden println() und print() Zeichenketten auf die Konsole ausgeben k\u00f6nnen und wir haben uns angeschaut, wie wir Fehlerausschriften lesen. Nun schauen wir uns einmal an, was im Hintergrund passiert, wenn wir das Programm ausf\u00fchren.","title":"Syntaxfehler"},{"location":"start/#kommentare","text":"In Ihren Quellcode (Ihr Programm) k\u00f6nnen Sie an allen beliebigen Stellen Kommentare schreiben. Kommentare werden vom Compiler ignoriert, d.h. Sie k\u00f6nnen dort hineinschreiben, was und wie Sie m\u00f6chten. Es gibt drei Arten von Kommentaren in Java: Zeilenkommentare : Diese beginnen mit // und danach kommt der Kommentar bis zum Zeilenende. Die neue Zeile ist dann wieder \"normaler\" Quellcode System . out . println ( \"Ausgabe1\" ); // hier ist ein Zeilenkommentar bis zum Ende der Zeile System . out . println ( \"Ausgabe2\" ); // hier ist noch ein Zeilenkommentar Blockkommentare : Diese beginnen mit /* und danach kommt der Kommentar. Er kann sich \u00fcber mehrere Zeilen erstrecken. Ein Blockkommentar endet mit */ . Nach diesem Ende ist sofort wieder \"normaler\" Quellcode. System . out . println ( \"Ausgabe1\" ); /* hier ist ein Blockkommentar er kann \u00fcber beliebig viele Zeilen gehen Er endet erst mit */ System . out . println ( \"Ausgabe2\" ); Java-Doc-Kommentare : javadoc ist ein Programm aus dem Java Development Kit (JDK) . Es wird eingesetzt, um den Code zu dokumentieren. Wir werden javadoc noch ausf\u00fchrlich behandeln. Mit javadoc kommentierte Klassen finden Sie hier . Java-Doc-Kommentare beginnen mit /** und enden mit */ . Java-Doc-Kommentare verhalten sich wie Blockkommentare. Sie erstrecken sich \u00fcber mehrere Zeilen und nach dem */ ist, wie bei Blockkommentaren, wieder \"normaler\" Quellcode. package uebungen.uebung0 ; /** * * @author jornfreiheit * * Das ist die erste Klasse, die wir geschrieben haben. * Sie erzeugt einfache Ausgaben von Zeichenketten auf * die Konsole. * */ public class MyFirstClass { // Hier die Implementierung unserer Klasse - nicht gezeigt }","title":"Kommentare"},{"location":"start/#compilieren-und-ausfuhren","text":"Wir haben nun unser erstes einfaches Programm geschrieben - in der Programmiersprache Java . Wie wir in Werkzeuge -> Java bereits bei der Installation von Java erl\u00e4utert haben, ist Java nicht nur eine Programmiersprache, sondern auch ein Programm, in dem wir Java-Programme ausf\u00fchren k\u00f6nnen - die Laufzeitumgebung von Java. Wir werden zun\u00e4chst erl\u00e4utern, was im Hintergrund passiert, wenn wir ein selbstgeschriebenes Java-Programm ausf\u00fchren. Zum besseren Verst\u00e4ndnis erzeugen wir uns zun\u00e4chst ein Verzeichnis test irgendwo auf unserem Rechner: mkdir test cd test Dieses Verzeichnis werden wir sp\u00e4ter wieder l\u00f6schen. Nun erzeugen wir uns mithilfe von vi oder vim eine Datei Test.java : vim Test.java Die Datei \u00f6ffnet sich zum Schreiben und nach Eingabe von i k\u00f6nnen wir in diese Datei Text einf\u00fcgen. Wir f\u00fcgen folgendes Programm ein (Kopieren Sie das Programm und f\u00fcgen es mit Strg+V in die Datei Test.java ein: Test.java 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test { public static void main ( String [] args ) { System . out . print ( \"Hello \" ); for ( String s : args ) { System . out . print ( s + \" \" ); } System . out . println ( \"!\" ); } } Beenden Sie den Einf\u00fcgemodus von vim durch Dr\u00fccken der Taste Esc und speichern die Datei und beenden vim unter Eingabe von ZZ . In unserem Ordner test befindet sich nun die Datei Test.java : ls -la zeigt den Inhalt unseres Verzeichnisses test an (z.B.): total 8 drwxr-xr-x@ 3 jornfreiheit staff 96 3 Aug 14 :17 . drwxr-xr-x@ 39 jornfreiheit staff 1248 1 Nov 2018 .. -rw-r--r-- 1 jornfreiheit staff 189 3 Aug 14 :17 Test.java Wir haben eine Klasse Test in der Datei erstellt, die genauso hei\u00dft, wie die Klasse, n\u00e4mlich Test.java . Wir werden in Zukunft immer die Klasse in der gleichnamigen Datei speichern, die die Dateiendung .java hat - das macht Eclipse f\u00fcr uns automatisch.","title":"Compilieren und Ausf\u00fchren"},{"location":"start/#compilieren-der-klasse","text":"Ein Computer kann keine Datei ausf\u00fchren, die in einer Programmiersprache geschrieben wurde, egal um welche Programmiersprache es sich handelt. Computer verstehen nur Folgen von Nullen und Einsen, also so etwas wie 1000111110101011... . In eine solche Maschinensprache muss unser Programm \u00fcbersetzt werden. Das \u00dcbersetzen erfolgt durch einen Compiler 2 . Der Java-Compiler hei\u00dft javac . Wir haben den Java-Compiler zusammen mit dem Java Development Kit (JDK) installiert (siehe hier ). Mithilfe des Compilers \u00fcbersetzen wir nun unsere Klasse: javac Test . java Wenn wir uns nun erneut den Inhalt unseres Verzeichnisses ansehen ls -la dann entdecken wir, dass eine Datei Test.class erzeugt wurde. total 16 drwxr-xr-x@ 4 jornfreiheit staff 128 7 Aug 11 :02 . drwxr-xr-x@ 39 jornfreiheit staff 1248 1 Nov 2018 .. -rw-r--r-- 1 jornfreiheit staff 1001 7 Aug 11 :02 Test.class -rw-r--r-- 1 jornfreiheit staff 189 3 Aug 14 :17 Test.java Unser Java-Compiler hat unser Programm, das in Test.java enthalten ist, in sogenannten Bytecode \u00fcbersetzt. Das ist ein Zwischenschritt, den es in Java gibt. Das Programm wird nicht direkt in Maschinencode \u00fcbersetzt, sondern in Bytecode.","title":"Compilieren der Klasse"},{"location":"start/#ausfuhren-des-programms","text":"Dieser Bytecode kann nun von der Java-Laufzeitumgebung (Java Runtime Environment - JRE) ausgef\u00fchrt werden. Diese Laufzeitumgebung ist selbst ein Programm, eine sogenannte Virtuelle Maschine 3 . Die Ausf\u00fchrung unseres Programms erfolgt mithilfe der Java-Laufzeitumgebung java : java Test Beachten Sie, dass Sie nicht die Dateiendung .class f\u00fcr Ihr Programm angeben (m\u00fcssen/d\u00fcrfen). Auf unserer Konsole erscheint die Ausgabe Hello ! Diese Ausgabe erfolgt durch die Anweisung System.out.print(\"Hello \"); (in Zeile 6 ), gefolgt von der Anweisung System.out.println(\"!\"); (in Zeile 11 ). In den Zeilen 7 - 10 stehen Anweisungen, die wir noch nicht verstehen. Das macht nichts, wir kommen sp\u00e4ter darauf zur\u00fcck. Es ist jedoch so, dass wir dadurch unserem Programm Argumente \u00fcbergeben k\u00f6nnen. Betrac hten wir zum Beispiel die Anweisung ls -la . ls w\u00e4re z.B. ein \"Programm\" und -la ein Argument ( -l sorgt daf\u00fcr, dass ein langes Listenformat erscheint, also alle Angaben zu den Dateien und Ordnern erscheinen und -a sorgt daf\u00fcr, dass auch die Dateien und Ordner angezeigt werden, die mit . beginnen). Versuchen wir also einmal, umserem Programm Test ein Argument zu \u00fcbergeben (ohne - ): java Test FIW Es erscheint die Ausgabe: Hello FIW ! Wir k\u00f6nnen sogar mehrere Argumente \u00fcbergeben: java Test FIW HTW Berlin Welt Es erscheint die Ausgabe: Hello FIW HTW Berlin Welt ! Es erscheint zun\u00e4chst aufwendig, das Programm zun\u00e4chst in Bytecode zu \u00fcbersetzen und dann den Bytecode nochmal interpretieren und ausf\u00fchren zu lassen. Warum wird nicht direkt in Maschinencode \u00fcbersetzt? Die Antwort ist, dass der Java-Compiler so beriebssystemunabh\u00e4ngig arbeiten kann. Alle, egal, ob Windows-, iOS- oder Linux-Nutzerinnen k\u00f6nnen den gleichen Compiler verwenden. Die Programme k\u00f6nnen v\u00f6llig systemunabh\u00e4ngig geschrieben und von allen compiliert werden. Erst die Java-Laufzeitumgebung ist beriebssystemabh\u00e4ngig, d.h. diese wird entsprechend dem Betriebssystem installiert. Alle Java-Programme und auch ihre Compilierung sind jedoch v\u00f6llig losgel\u00f6st vom verwendeten Betriebssystem und k\u00f6nnen deshalb \u00fcberall ausgef\u00fchrt werden. Success Wir haben uns angeschaut, was passiert, wenn wir das Programm \u00fcbersetzen und ausf\u00fchren. Die \u00dcbersetzung erfolgt durch den Java-Compiler javac . Dieser erzeugt Java-Bytecode . Die Ausf\u00fchrung dieses Bytcodes \u00fcbernimmt die Java-Laufzeitumgebung java . Diese interpretiert den Bytecode und f\u00fchrt ihn sequentiell (also nacheinander, Anweisung f\u00fcr Anweisung) aus. Wenn wir ganz genau sein wollen, dann ist out vom Typ PrintStream und wir greifen auf die Objektmethode println() des PrintStream -Objektes out zu. \u21a9 Man unterscheidet bei Programmiersprachen, ob die Programme durch einen Compiler oder durch einen Interpreter \u00fcbersetzt werden. Programmiersprachen, bei denen die Programme durch einen Interpreter \u00fcbersetzt werden, werden auch Skriptsprachen genannt. In Skriptsprachen wird jede einzelne Anweisung nach und nach interpretiert , d.h. \u00fcbersetzt, dann ausgef\u00fchrt, dann die n\u00e4chste Anweisung \u00fcbersetzt, ausgef\u00fchrt usw. Java-Programme werden compiliert, d.h. sie werden als Ganzes \u00fcbersetzt und erst dann ausgef\u00fchrt. \u21a9 Genauer handelt es sich dabei um einen Interpreter . Der Java-Bytecode wird Anweisung f\u00fcr Anweisung interpretiert und ausgef\u00fchrt. \u21a9","title":"Ausf\u00fchren des Programms"},{"location":"tools/","text":"Werkzeuge \u00b6 Literaturempfehlungen \u00b6 Joachim Goll, Cornelia Heinisch: \"Java als erste Programmiersprache. Ein professioneller Einstieg in die Objektorientierung mit Java\" , Springer Vieweg Sebastian D\u00f6rn: \"Java lernen in abgeschlossenen Lerneinheiten\" , Springer Vieweg Dietmar Ratz, Jens Scheffler, Detlef Seese, Jan Wiesenberger: \"Grundkurs Programmieren in Java x\" , Hanser Verlag Kathy Sierra, Bert Bates: \"Java von Kopf bis Fu\u00df\" , O'Reilly Verlag Joshua Bloch: \"Effective Java. Best practices for the Java platform\" , Pearson Education Inc. Robin C. Martin: \"Clean Code: A Handbook of Agile Software Craftmanship\" , Prentice Hall und alle B\u00fccher f\u00fcr Einsteigerinnen, die Sie ansprechen... Java \u00b6 Wir verwenden die Programmiersprache Java , um die Programmierkonzepte, die wir lernen und anwenden wollen, zu implementieren. Java besteht aus 2 Teilen: der Java Run Time Environment (Java RTE) (Java-Laufzeitumgebung) dem Java Development Kit (JDK) (die Java-Entwicklungsumgebung) Die Java-Laufzeitumgebung ist \u00fcblicherweise bereits auf allen Rechnern installiert. Sie ist selbst ein Programm. Innerhalb dieses Programms werden Java-Programme ausgef\u00fchrt. Das JDK m\u00fcssen Sie installieren. Verwenden Sie dazu diesen Link und gehen wie f\u00fcr Ihr Betriebssystem angegeben vor (pr\u00fcfen Sie aber zun\u00e4chst, ob Sie nicht eventuell bereits Beides haben - java -version und javac -version - siehe folgend). Testen Sie am besten auf Ihrer Konsole (Terminal), ob Ihr Java korrekt funktioniert. Zum Testen Ihrer Laufzeitumgebung geben Sie dazu java -version ein. Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): java version \"15.0.1\" 2020 -10-20 Java ( TM ) SE Runtime Environment ( build 15 .0.1+9-18 ) Java HotSpot ( TM ) 64 -Bit Server VM ( build 15 .0.1+9-18, mixed mode, sharing ) Somit wissen Sie, dass die Laufzeitumgebung funktioniert. Zum Testen des JDK rufen wir am besten den Compiler ( javac ) auf: javac -version Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): javac 15 .0.1 Success Sie haben nun die Java-Laufzeitumgebung installiert, in der unsere Java-Programme ausgef\u00fchrt werden und Sie haben das Java Development Kit installiert. Teil des JDK ist z.B. der Compiler , der unsere Java-Programme in Byte-Code \u00fcbersetzt. Dieser Bytecode wird in unserer Java-Laufzeitumgebung ausgef\u00fchrt. IDE \u00b6 Um unsere Programme \"zu schreiben\", verwenden wir eine sogenannte Integrated Development Environment (IDE) , eine integrierte Entwicklungsumgebung, die uns beim Programmieren unterst\u00fctzt. Wir k\u00f6nnten unsere Programme auch mit einfachen Texteditoren schreiben, aber eine IDE unterst\u00fctzt uns, indem der Programmcode geeignet hervorgehoben wird ( Syntx-Highlighting ) und uns Vorschl\u00e4ge f\u00fcr die Verwendung von Methoden und Variablen gemacht werden ( Intelligent Code Completion ). Eclipse \u00b6 Sie sind in der Wahl Ihrer IDE frei. Wir verwenden Eclipse . Eclipse ist in Java geschrieben und Open-Source. Den Download-Link f\u00fcr Eclipse finden Sie hier . Es gibt verschiedene Versionen von Eclipse, wir verwenden die Eclipse IDE for Java Developers . Installieren Sie Eclipse am besten in ihren Applications oder Programme Ordner. Starten Sie Eclipse durch Doppelklick auf das Programmsymbol. Erstellen Sie einen Workspace (Arbeitsbereich) in einem gewu\u0308nschten Ordner (z. B. Programmieren) im Dateisystem. Achten Sie darauf, dass Sie Schreibrechte in diesem Ordner besitzen. Anlegen eines Projektordners: Auswahl im Men\u00fc File-->New-->Java Project . Eingabe des Project name: Name des Projektes (z.B. WiSe20 oder Uebung1 oder Aufgabe2 ). Wenn Sie gefragt werden, ob Sie ein module-info.java erstellen wollen, w\u00e4hlen Sie Don't create . Klicken auf den Button Finish . Erstellen eines neuen Packages (Paketes): \u00d6ffnen der Projektmappe im Package Explorer . Auswahl des Ordners src mit der rechten Maustaste. Auswahl des Men\u00fcpunktes New --> Package . Geben Sie einen Paketnamen ein (Paketnamen werden kleingeschrieben), z.B. themen.start . Erstellen einer neuen Klasse: \u00d6ffnen der Projektmappe im Package Explorer. Auswahl des Paketes (z.B. themen.start ) mit der rechten Maustaste. Auswahl des Menu\u0308punktes New --> Class . Eingabe eines beliebigen Namens, der gleichzeitig der Klassen- und Dateiname ist (z.B. HelloFIW ). Klassennamen werden immer gro\u00df geschrieben. Setzen des H\u00e4kchens bei public static void main() . Klicken auf den Button Finish . Die folgende Abbildung gibt einen \u00dcberblick \u00fcber die Bedeutung der einzelnen Fenster in Eclipse: IntelliJ \u00b6 Diejenigen von Ihnen, die nicht Eclipse verwenden, werden sich stattdessen wahrscheinlich f\u00fcr IntelliJ entscheiden. Das ist v\u00f6llig in Ordnung. IntelliJ ist von JetBrains, einem tschechischen Unternehmen, und derzeit die wohl modernste IDE auf dem Markt, nicht nur f\u00fcr Java- sondern auch f\u00fcr Web-Entwicklungen. IntelliJ ist nicht Open-Source und ist kostenpflichtig. Mit einer Hochschullizenz erhalten Sie jedoch kostenlosen Zugriff auf alle Enterprise-Versionen. Sie m\u00fcssen sich dazu bei JetBrains mit Ihrer HTW-Adresse registrieren. Visual Studio Code \u00b6 Wer gerne mit Microsoft-Produkten arbeitet, kann auch gerne Visual Studio Code ( VS Code ) arbeiten. Das ist auch eine sehr gute IDE und ebenfalls nicht nur zur Nutzung f\u00fcr die Java-Entwicklung, sondern auch f\u00fcr Web- und App-Entwicklungen geeignet. Sp\u00e4testens im dritten Semster in WebTech werden die meisten von Ihnen entweder auf IntelliJ oder VS Code wechseln. Weitere n\u00fctzliche Werkzeuge \u00b6 Windows: gitBash \u00b6 Das Terminal ( cmd ) in Windows ist nicht so gut. Installieren Sie sich lieber die GitBash f\u00fcr Windows . Unter Downloads \u00f6ffnet sich das GitHub-Repository f\u00fcr Git. Aktuell w\u00e4hlen Sie dort Git-2.29.2-64-bit.exe und folgen dann den Installationsanweisungen. Online-Kurse \u00b6 SoloLearn https://www.sololearn.com/Course/Java/ JetBrains Academy https://hyperskill.org/tracks/1","title":"Werkzeuge"},{"location":"tools/#werkzeuge","text":"","title":"Werkzeuge"},{"location":"tools/#literaturempfehlungen","text":"Joachim Goll, Cornelia Heinisch: \"Java als erste Programmiersprache. Ein professioneller Einstieg in die Objektorientierung mit Java\" , Springer Vieweg Sebastian D\u00f6rn: \"Java lernen in abgeschlossenen Lerneinheiten\" , Springer Vieweg Dietmar Ratz, Jens Scheffler, Detlef Seese, Jan Wiesenberger: \"Grundkurs Programmieren in Java x\" , Hanser Verlag Kathy Sierra, Bert Bates: \"Java von Kopf bis Fu\u00df\" , O'Reilly Verlag Joshua Bloch: \"Effective Java. Best practices for the Java platform\" , Pearson Education Inc. Robin C. Martin: \"Clean Code: A Handbook of Agile Software Craftmanship\" , Prentice Hall und alle B\u00fccher f\u00fcr Einsteigerinnen, die Sie ansprechen...","title":"Literaturempfehlungen"},{"location":"tools/#java","text":"Wir verwenden die Programmiersprache Java , um die Programmierkonzepte, die wir lernen und anwenden wollen, zu implementieren. Java besteht aus 2 Teilen: der Java Run Time Environment (Java RTE) (Java-Laufzeitumgebung) dem Java Development Kit (JDK) (die Java-Entwicklungsumgebung) Die Java-Laufzeitumgebung ist \u00fcblicherweise bereits auf allen Rechnern installiert. Sie ist selbst ein Programm. Innerhalb dieses Programms werden Java-Programme ausgef\u00fchrt. Das JDK m\u00fcssen Sie installieren. Verwenden Sie dazu diesen Link und gehen wie f\u00fcr Ihr Betriebssystem angegeben vor (pr\u00fcfen Sie aber zun\u00e4chst, ob Sie nicht eventuell bereits Beides haben - java -version und javac -version - siehe folgend). Testen Sie am besten auf Ihrer Konsole (Terminal), ob Ihr Java korrekt funktioniert. Zum Testen Ihrer Laufzeitumgebung geben Sie dazu java -version ein. Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): java version \"15.0.1\" 2020 -10-20 Java ( TM ) SE Runtime Environment ( build 15 .0.1+9-18 ) Java HotSpot ( TM ) 64 -Bit Server VM ( build 15 .0.1+9-18, mixed mode, sharing ) Somit wissen Sie, dass die Laufzeitumgebung funktioniert. Zum Testen des JDK rufen wir am besten den Compiler ( javac ) auf: javac -version Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): javac 15 .0.1 Success Sie haben nun die Java-Laufzeitumgebung installiert, in der unsere Java-Programme ausgef\u00fchrt werden und Sie haben das Java Development Kit installiert. Teil des JDK ist z.B. der Compiler , der unsere Java-Programme in Byte-Code \u00fcbersetzt. Dieser Bytecode wird in unserer Java-Laufzeitumgebung ausgef\u00fchrt.","title":"Java"},{"location":"tools/#ide","text":"Um unsere Programme \"zu schreiben\", verwenden wir eine sogenannte Integrated Development Environment (IDE) , eine integrierte Entwicklungsumgebung, die uns beim Programmieren unterst\u00fctzt. Wir k\u00f6nnten unsere Programme auch mit einfachen Texteditoren schreiben, aber eine IDE unterst\u00fctzt uns, indem der Programmcode geeignet hervorgehoben wird ( Syntx-Highlighting ) und uns Vorschl\u00e4ge f\u00fcr die Verwendung von Methoden und Variablen gemacht werden ( Intelligent Code Completion ).","title":"IDE"},{"location":"tools/#eclipse","text":"Sie sind in der Wahl Ihrer IDE frei. Wir verwenden Eclipse . Eclipse ist in Java geschrieben und Open-Source. Den Download-Link f\u00fcr Eclipse finden Sie hier . Es gibt verschiedene Versionen von Eclipse, wir verwenden die Eclipse IDE for Java Developers . Installieren Sie Eclipse am besten in ihren Applications oder Programme Ordner. Starten Sie Eclipse durch Doppelklick auf das Programmsymbol. Erstellen Sie einen Workspace (Arbeitsbereich) in einem gewu\u0308nschten Ordner (z. B. Programmieren) im Dateisystem. Achten Sie darauf, dass Sie Schreibrechte in diesem Ordner besitzen. Anlegen eines Projektordners: Auswahl im Men\u00fc File-->New-->Java Project . Eingabe des Project name: Name des Projektes (z.B. WiSe20 oder Uebung1 oder Aufgabe2 ). Wenn Sie gefragt werden, ob Sie ein module-info.java erstellen wollen, w\u00e4hlen Sie Don't create . Klicken auf den Button Finish . Erstellen eines neuen Packages (Paketes): \u00d6ffnen der Projektmappe im Package Explorer . Auswahl des Ordners src mit der rechten Maustaste. Auswahl des Men\u00fcpunktes New --> Package . Geben Sie einen Paketnamen ein (Paketnamen werden kleingeschrieben), z.B. themen.start . Erstellen einer neuen Klasse: \u00d6ffnen der Projektmappe im Package Explorer. Auswahl des Paketes (z.B. themen.start ) mit der rechten Maustaste. Auswahl des Menu\u0308punktes New --> Class . Eingabe eines beliebigen Namens, der gleichzeitig der Klassen- und Dateiname ist (z.B. HelloFIW ). Klassennamen werden immer gro\u00df geschrieben. Setzen des H\u00e4kchens bei public static void main() . Klicken auf den Button Finish . Die folgende Abbildung gibt einen \u00dcberblick \u00fcber die Bedeutung der einzelnen Fenster in Eclipse:","title":"Eclipse"},{"location":"tools/#intellij","text":"Diejenigen von Ihnen, die nicht Eclipse verwenden, werden sich stattdessen wahrscheinlich f\u00fcr IntelliJ entscheiden. Das ist v\u00f6llig in Ordnung. IntelliJ ist von JetBrains, einem tschechischen Unternehmen, und derzeit die wohl modernste IDE auf dem Markt, nicht nur f\u00fcr Java- sondern auch f\u00fcr Web-Entwicklungen. IntelliJ ist nicht Open-Source und ist kostenpflichtig. Mit einer Hochschullizenz erhalten Sie jedoch kostenlosen Zugriff auf alle Enterprise-Versionen. Sie m\u00fcssen sich dazu bei JetBrains mit Ihrer HTW-Adresse registrieren.","title":"IntelliJ"},{"location":"tools/#visual-studio-code","text":"Wer gerne mit Microsoft-Produkten arbeitet, kann auch gerne Visual Studio Code ( VS Code ) arbeiten. Das ist auch eine sehr gute IDE und ebenfalls nicht nur zur Nutzung f\u00fcr die Java-Entwicklung, sondern auch f\u00fcr Web- und App-Entwicklungen geeignet. Sp\u00e4testens im dritten Semster in WebTech werden die meisten von Ihnen entweder auf IntelliJ oder VS Code wechseln.","title":"Visual Studio Code"},{"location":"tools/#weitere-nutzliche-werkzeuge","text":"","title":"Weitere n\u00fctzliche Werkzeuge"},{"location":"tools/#windows-gitbash","text":"Das Terminal ( cmd ) in Windows ist nicht so gut. Installieren Sie sich lieber die GitBash f\u00fcr Windows . Unter Downloads \u00f6ffnet sich das GitHub-Repository f\u00fcr Git. Aktuell w\u00e4hlen Sie dort Git-2.29.2-64-bit.exe und folgen dann den Installationsanweisungen.","title":"Windows: gitBash"},{"location":"tools/#online-kurse","text":"SoloLearn https://www.sololearn.com/Course/Java/ JetBrains Academy https://hyperskill.org/tracks/1","title":"Online-Kurse"},{"location":"uebungen/","text":"\u00dcbungen \u00b6 \u00dcbungsbl\u00e4tter (wochenweise) \u00b6 \u00dcbung 0 Installieren Sie sich - falls noch nicht geschehen - eine Java-Entwicklungsumgebung (siehe Java ). Installieren Sie sich die IDE Ihrer Wahl (siehe IDE ). In den Vorlesungen und \u00dcbungen verwende ich Eclipse und beschreibe die Schritte auch f\u00fcr Eclipse. Starten Sie Eclipse durch Doppelklick auf das Programmsymbol. Erstellen Sie einen Workspace (Arbeitsbereich) in einem gewu\u0308nschten Ordner (z. B. Prog12 ) im Dateisystem. Achten Sie darauf, dass Sie Schreibrechte in diesem Ordner besitzen. Anlegen eines Projektordners: Auswahl im Men\u00fc File-->New-->Java Project . Eingabe des Project name: Name des Projektes (z.B. WiSe22 ). Klicken auf den Button Finish . Das Fenster New module-info.java k\u00f6nnen Sie einfach mit Create best\u00e4tigen. Erstellen eines neuen Packages (Paketes): \u00d6ffnen der Projektmappe im Package Explorer . Auswahl des Ordners src mit der rechten Maustaste. Auswahl des Men\u00fcpunktes New --> Package . Geben Sie folgenden Paketnamen ein (Paketnamen werden kleingeschrieben) uebungen.uebung0 (Achten Sie auf den Punkt und dass Sie alles zusammen schreiben). Erstellen einer neuen Klasse: \u00d6ffnen der Projektmappe im Package Explorer. Auswahl des Paketes ( uebungen.uebung0 ) mit der rechten Maustaste. Auswahl des Menu\u0308punktes New --> Class . Eingabe des Namens, der gleichzeitig der Klassen- und Dateiname ist: Uebung0 . Klassennamen werden immer gro\u00df geschrieben. Setzen des H\u00e4kchens bei public static void main() . (Sollten Sie vergessen haben, das H\u00e4kchen zu setzen, dann ist die Klasse, nachdem Sie Finish gedr\u00fcckt haben, leer. Setzen Sie dann den Cursor zwischen die beiden geschweiften Klammern { } , geben dann main ein und dr\u00fccken die Ctrl + Leer -Tasten und anschlie\u00dfend Enter . Dann erscheint die main() -Methode) Klicken auf den Button Finish . In die main() -Methode (zwischen die geschweiften Klammern { und } geben Sie ein: System.out.println(\"Uebung 0\")); . Dr\u00fccken Sie dann entweder auf den -Button oder w\u00e4hlen Sie aus dem Men\u00fc Run --> Run oder dr\u00fccken Sie shift + command + f11 . In der Console in Ihrer IDE (in Eclipse unten) erscheint Uebung 0 . Uebung1.java package uebungen.uebung0 ; public class Uebung0 { public static void main ( String [] args ) { System . out . println ( \"Uebung 0\" ); } } Success Fertig! Ihre Entwicklungsumgebung ist bereit! Wir k\u00f6nnen loslegen. \u00dcbung 1 (Aufgabe folgt)","title":"\u00dcbungen"},{"location":"uebungen/#ubungen","text":"","title":"\u00dcbungen"},{"location":"uebungen/#ubungsblatter-wochenweise","text":"\u00dcbung 0 Installieren Sie sich - falls noch nicht geschehen - eine Java-Entwicklungsumgebung (siehe Java ). Installieren Sie sich die IDE Ihrer Wahl (siehe IDE ). In den Vorlesungen und \u00dcbungen verwende ich Eclipse und beschreibe die Schritte auch f\u00fcr Eclipse. Starten Sie Eclipse durch Doppelklick auf das Programmsymbol. Erstellen Sie einen Workspace (Arbeitsbereich) in einem gewu\u0308nschten Ordner (z. B. Prog12 ) im Dateisystem. Achten Sie darauf, dass Sie Schreibrechte in diesem Ordner besitzen. Anlegen eines Projektordners: Auswahl im Men\u00fc File-->New-->Java Project . Eingabe des Project name: Name des Projektes (z.B. WiSe22 ). Klicken auf den Button Finish . Das Fenster New module-info.java k\u00f6nnen Sie einfach mit Create best\u00e4tigen. Erstellen eines neuen Packages (Paketes): \u00d6ffnen der Projektmappe im Package Explorer . Auswahl des Ordners src mit der rechten Maustaste. Auswahl des Men\u00fcpunktes New --> Package . Geben Sie folgenden Paketnamen ein (Paketnamen werden kleingeschrieben) uebungen.uebung0 (Achten Sie auf den Punkt und dass Sie alles zusammen schreiben). Erstellen einer neuen Klasse: \u00d6ffnen der Projektmappe im Package Explorer. Auswahl des Paketes ( uebungen.uebung0 ) mit der rechten Maustaste. Auswahl des Menu\u0308punktes New --> Class . Eingabe des Namens, der gleichzeitig der Klassen- und Dateiname ist: Uebung0 . Klassennamen werden immer gro\u00df geschrieben. Setzen des H\u00e4kchens bei public static void main() . (Sollten Sie vergessen haben, das H\u00e4kchen zu setzen, dann ist die Klasse, nachdem Sie Finish gedr\u00fcckt haben, leer. Setzen Sie dann den Cursor zwischen die beiden geschweiften Klammern { } , geben dann main ein und dr\u00fccken die Ctrl + Leer -Tasten und anschlie\u00dfend Enter . Dann erscheint die main() -Methode) Klicken auf den Button Finish . In die main() -Methode (zwischen die geschweiften Klammern { und } geben Sie ein: System.out.println(\"Uebung 0\")); . Dr\u00fccken Sie dann entweder auf den -Button oder w\u00e4hlen Sie aus dem Men\u00fc Run --> Run oder dr\u00fccken Sie shift + command + f11 . In der Console in Ihrer IDE (in Eclipse unten) erscheint Uebung 0 . Uebung1.java package uebungen.uebung0 ; public class Uebung0 { public static void main ( String [] args ) { System . out . println ( \"Uebung 0\" ); } } Success Fertig! Ihre Entwicklungsumgebung ist bereit! Wir k\u00f6nnen loslegen. \u00dcbung 1 (Aufgabe folgt)","title":"\u00dcbungsbl\u00e4tter (wochenweise)"}]}